; Ethlet to set a static ip address for etherload
; ip address will be stored in colour ram after the ETHLOAD.M65 code at $FF87FFC 

	; Routine sits at beginning of UDP payload in the Ethernet buffer
	; mapped at $6800
	; Packet size:      2 bytes
	; Ethernet header: 14 bytes
	; IPv4 header:     20 bytes
	; UDP header:       8 bytes
	.org $6800 + 2 + 14 + 20 + 8

    .alias pkt_len      ip_address + 4 - $6802

entry:

	; Dummy inc $d020 jmp *-3 routine for debugging
;	lda #$00
;	inc $d020
;*
;	jmp -

	; Production routine that skips the jmp *-3 loop
	lda #$00
	nop
	nop
	nop
	nop
	nop
	nop

	; Enable mega65 I/O personality
	lda #$47
	sta $d02f
	lda #$53
	sta $d02f

    ; we expect the ETHLOAD.M65 code still to be mapped at $8000
    ; ip address shall thus be put at $80fc
    ldx #$03
*	lda ip_address,x
    sta $80fc,x
    dex
    bpl -

	; Wait for TX ready
*
	lda $d6e1
	and #$10
	beq -

	; Use chained DMA to copy packet to TX buffer, and then send it
	; so that we can get what will effectively be an ACK to each
	; packet received by the MEGA65.
	sta $d707 ; trigger in-line DMA
	.byte $80, $ff
	.byte $81, $ff
	.byte $00      ; DMA end of option list
	.byte $04      ; DMA copy, chained
	.word pkt_len  ; DMA byte count 
	.word $e802    ; DMA source address (bottom 16 bits) 
	.byte $8d      ; DMA source bank and flags ($8x = I/O enabled)
	.word $e800    ; DMA destination address (bottom 16 bits)
	.byte $8d      ; DMA destination bank and flags
	.byte $00      ; DMA sub command
	.word $0000    ; DMA modulo (ignored)

	; Use DMA to swap MAC addresses
	.byte $00      ; DMA end of option list
	.byte $04      ; DMA copy, chained
	.word $0006    ; DMA byte count 
	.word $e808    ; DMA source address (bottom 16 bits) 
	.byte $8d      ; DMA source bank and flags ($8x = I/O enabled)
	.word $e800    ; DMA destination address (bottom 16 bits)
	.byte $8d      ; DMA destination bank and flags
	.byte $00      ; DMA sub command
	.word $0000    ; DMA modulo (ignored)

	.byte $00      ; DMA end of option list
	.byte $00      ; DMA copy, end of chain
	.word $0006    ; DMA byte count 
	.word $36e9    ; DMA source address (bottom 16 bits), ffd36e9 = MACADDRx registers
	.byte $8d      ; DMA source bank and flags ($8x = I/O enabled)
	.word $e806    ; DMA destination address (bottom 16 bits)
	.byte $8d      ; DMA destination bank and flags
	.byte $00      ; DMA sub command
	.word $0000    ; DMA modulo (ignored)

	; Code resumes after DMA list here

	; basepage = $68xx, so we can use basepage addressing for reading/writing the ethernet buffer
	lda #$68
	tab

	; Reverse port numbers
	; Note that reading is accessing rx buffer (starts at 6802), while writing
	; accesses the tx buffer (starts at 6800).
	lda $24
	sta $24
	lda $25
	sta $25

	lda $26
	sta $22
	lda $27
	sta $23

	; Set packet len
	lda #<pkt_len
	sta $d6e2
	lda #>pkt_len
	sta $d6e3

	; swap src/dst ip addresses (no need to recalc ip chks as this change won't alter it)
	; $1c - $1f = rx src ip
	; $20 - $23 = rx dst ip
	; $1a - $1d = tx src ip
	; $1e - $21 = tx dst ip
	ldx #$03
*
	lda $1c,x
	sta $1e,x
	lda $20,x
	sta $1a,x
	dex
	bpl -	

	; 5. TX packet
	lda #$01
	sta $d6e4

	; restore basepage
	lda #$00
	tab

	; Return to packet wait loop
    rts

ip_address:
	.byte 0, 0, 0, 0

