#!/usr/bin/python

import sys
if sys.version_info < (3, 8):
    sys.exit("This tool requires python 3.8 or later!")

import argparse
import struct
import datetime
import re
import shutil
import fnmatch
from pathlib import Path
from array import array
from binascii import crc32
from itertools import zip_longest
from typing import Optional, Union, List, Tuple, Dict
from dataclasses import dataclass

##
## CONSTANTS
##
CORE_MAGIC: bytes = b'MEGA65BITSTREAM0'
CORE_CRC32: bytes = b'\xf0\xf0\xf0\xf0'
CORE_CRC32_I: int = 0xf0f0f0f0
BANNER_SIZE: int = 32768
FACTORY_NAME: str = 'MEGA65'

VIVADO_BIT_HEADER: bytes = b'\x00\x09\x0f\xf0\x0f\xf0\x0f\xf0\x0f\xf0\x00\x00\x01'
TRUNCBIT_MAGIC: bytes = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
SYNCWORD: bytes = b'\xaa\x99\x55\x66'


##
## Utility Functions
##
def zero_string(value: bytes, encoding: str) -> str:
    """
    converts bytes into str using encoding.
    will cut string at the first zero byte.
    """
    i = value.find(b'\x00')
    if i:
        value = value[:i]
    return value.decode(encoding)


NOFILECHARre = re.compile(r'[^a-zA-Z0-9._~-]')
def sanitize_filename(value: str) -> Path:
    return Path(NOFILECHARre.sub('_', value))


def supports_color():
    """
    Returns True if the running system's terminal supports color, and False
    otherwise.
    """
    plat = sys.platform
    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or 'ANSICON' in os.environ)
    # isatty is not always implemented, #6223.
    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    return supported_platform and is_a_tty


def RGB(red: Optional[int] = None, green: Optional[int] = None, blue: Optional[int] = None, bg: bool = False, bold: bool = False):
    if not bg and red is not None and green is not None and blue is not None:
        return f'\u001b[{"1;" if bold else ""}38;2;{red};{green};{blue}m'
    elif bg and red is not None and green is not None and blue is not None:
        return f'\u001b[{"1;" if bold else ""}48;2;{red};{green};{blue}m'
    elif red is None and green is None and blue is None:
        return f'\u001b[0{";1" if bold else ""}m'


DO_COLOR: bool = supports_color()
WIDTH: int = 98

CST = RGB()
COK = RGB(0,255,0)
CER = RGB(255,0,0)
CBOLD = RGB(bold=True)

CHAR_CHECK: str = '\u2714'
CHAR_CROSS: str = '\u2717'
CHAR_ERROR: str = '\u2717'

def format_error_line(msg: str, error: Optional[Union[str, List[str]]] = None):
    global DO_COLOR, WIDTH

    iserror: bool = False
    the_error: str = ''
    the_error_base: str = ''
    if isinstance(error, list):
        iserror = False
        for err in error:
            if err:
                iserror = True
                the_error = err
                break
    elif isinstance(error, str):
        iserror = True
        the_error = error

    msg_base: str = msg.replace('@@', CHAR_CHECK if not iserror else CHAR_CROSS)
    if DO_COLOR:
        msg = msg.replace('@@', COK+CHAR_CHECK+CST if not iserror else CER+CHAR_CROSS+CST)
    else:
        msg = msg_base

    if iserror:
        msg += '  '
        msg_base += '  '
        the_error_base = CHAR_ERROR + ' ' + the_error
        if DO_COLOR:
            the_error = CER+CHAR_ERROR+CST + ' ' + the_error
        else:
            the_error = the_error_base
        if WIDTH - len(msg_base) < len(the_error_base):
            msg += '\n' + ' ' * (WIDTH - len(the_error_base)) + the_error
        else:
            msg += ' ' * (WIDTH - len(msg_base) - len(the_error_base)) + the_error
    return msg


class FileError(Exception): pass


class ErrorHandler:

    def __init__(self):
        self._errors: Dict[str: List[str]] = {}

    def __setitem__(self, key: str, value: str):
        self._errors.setdefault(key, []).append(value)
    
    def __getitem__(self, key: str) -> List[str]:
        return self._errors[key]

    def get(self, key: str) -> List[str]:
        return self._errors.get(key, [])


@dataclass(frozen=True)
class MEGA65target:
    name: str
    code: int
    size: int
    fpga: int


class MEGA65targets:

    targets = [
        MEGA65target("mega65r1",        0x01, 8192, "7a200tfbg484"),
        MEGA65target("mega65r2",        0x02, 4096, "7a100tcsg324"),
        MEGA65target("mega65r3",        0x03, 8192, "7a200tfbg484"),
        MEGA65target("mega65r4",        0x04, 8192, "7a200tfbg484"),
        MEGA65target("mega65r5",        0x05, 8192, "7a200tfbg484"),
        MEGA65target("mega65r6",        0x06, 8192, "7a200tfbg484"),
        MEGA65target("megaphoner1",     0x21, 4096, "7a100tcsg324"),
        MEGA65target("nexys4",          0x40, 4096, "7a100tcsg324"),
        MEGA65target("nexys4ddr",       0x41, 4096, "7a100tcsg324"),
        MEGA65target("nexys4ddrwidget", 0x42, 4096, "7a100tcsg324"),
        MEGA65target("wukonga100t",     0xFD, 4096, "7a100tcsg324")
    ]

    def __init__(self):
        self._by_name: dict = {}
        self._by_code: dict = {}
        self._by_fpga: dict = {}
        for t in self.targets:
            self._by_name[t.name] = t
            self._by_code[t.code] = t
            self._by_fpga.setdefault(t.fpga, []).append(t)

    def by_name(self, key: str) -> MEGA65target:
        return self._by_name.get(key, None)

    def by_code(self, key: int) -> MEGA65target:
        return self._by_code.get(key, None)

    def by_fpga(self, key: str) -> List[MEGA65target]:
        return self._by_fpga.get(key, None)

    def get(self, key: any) -> Union[MEGA65target, List[MEGA65target]]:
        if type(key) is int:
            return self._by_code.get(key, None)
        return self._by_name.get(key, self._by_fpga.get(key, None))
    
    def get_help(self, indent: str = '') -> str:
        lines = [('Targetname', 'Code - FPGA Part'), ('===========', '===================')] + [(f"{x.name}", f"0x{x.code:02X} - {x.fpga}") for x in self.targets]
        fmtlen = max([len(x[0]) for x in lines])
        lines = [(x[0], ' '*(fmtlen - len(x[0])), x[1]) for x in lines]
        return '\n'.join([f"{indent}{x[0]} {x[1]}{x[2]}" for x in lines])


class MEGA65flags:

    _name = 'key'

    def __init__(self):
        self.flag2name = {x: y[0] for x, y in self._options.items()}
        self.name2flag = {y[0]: x for x, y in self._options.items()}
        self.helptext = [f'{x[0]}: {x[1]}' for x in self._options.values() if x[0][0] != '_']
        self.ok_mask = 0
        for x in self._options:
            self.ok_mask |= x
        self.bad_mask = 0xff ^ self.ok_mask

    def get(self, key: str) -> int:
        return self.name2flag.get(key, 0)
    
    def match(self, key: str) -> Optional[str]:
        res = None
        for name in self.name2flag:
            if name.startswith(key):
                if res is not None:
                    return None
                res = name
        return res

    def parse_str(self, value: str) -> Tuple[int, List[str]]:
        errors: List[str] = []
        flag: int = 0
        for key in value.split(','):
            if not key:
                continue
            if key[0] == '_':
                errors.append(f'!hidden {self._name} "{key}"')
                continue
            name: str = self.match(key.lower())
            if name is None:
                errors.append(f'!unknown {self._name} "{key}"')
                continue
            flag |= self.get(name)
        return flag, errors

    def get_options(self) -> List[str]:
        return [x for x in self.name2flag.keys() if x[0] != '_']

    def get_active(self, value: int) -> List[str]:
        return [y for x, y in self.flag2name.items() if value & x]
    
    def get_active_str(self, value: int, join_str: str = ', ', empty_str: str = 'none') -> str:
        active = self.get_active(value)
        if not active:
            return empty_str
        return join_str.join(active)

    def has_invalid_bits(self, value: int) -> bool:
        return (value & self.bad_mask) != 0

    def make_valid(self, value: int) -> bool:
        return value & self.ok_mask

    def check(self, key: str, value: int) -> bool:
        if key not in self.name2flag:
            raise KeyError(f"unknown flag key '{key}'")
        return (value & self.name2flag[key]) != 0
    
    def get_help(self, indent: str = '') -> str:
        return '\n'.join([indent + x for x in self.helptext])

class MEGA65capflags(MEGA65flags):

    _name = 'capability'

    _options = {
        0b10000000: ('default', 'Core is booted as the default core.'),
        0b00000001: ('m65cart', 'Core can handle M65 cartridge, and is started if one is detected.'),
        0b00000010: ('c64cart', 'Core can handle C64 cartridge, and is started if one is detected.'),
        0b00000100: ('c128cart', 'Core can handle C128 cartridge, and is started if one is detected.'),
    }


class MEGA65instflags(MEGA65flags):

    _name = 'install flag'

    _options = {
        0b00000001: ('factory', 'Is suited as SLOT0 FACTORY CORE'),
        0b00000010: ('auto', 'Skips security questions (factory)'),
        0b01000000: ('_eraselist', 'Has eraslist embedded'),
        0b10000000: ('force', 'Is automatically installed by MEGAFLASH (factory)'),
    }


M65_TARGETS = MEGA65targets()
M65_CAPS = MEGA65capflags()
M65_INST = MEGA65instflags()


class ContentElement:

    def __init__(self, name: str, raw_data: bytes):
        self._name: str = name
        self._raw_data: bytes = raw_data

    @property
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, value: str):
        self._name = value

    @property
    def raw_data(self) -> bytes:
        return self._raw_data

    @raw_data.setter
    def raw_data(self, value: bytes):
        self._raw_data = value

    @property
    def raw_data_length(self) -> int:
        return len(self._raw_data) if self._raw_data else 0

    def __repr__(self) -> str:
        return f'<ContentElement "{self.name}" {len(self.raw_data)} bytes>'
    
    def save_data(self, path: Path):
        path.open('wb').write(self._raw_data)


class EmbeddedFile(ContentElement):

    def __init__(self, name: str, raw_data: bytes, offset: Optional[int] = None, next: Optional[int] = None):
        ContentElement.__init__(self, name, raw_data)
        self._offset: Optional[int] = offset
        self._next: Optional[int] = next
        self.errors: List[Optional[str]] = []
    
    @property
    def offset(self) -> Optional[int]:
        return self._offset
    
    @offset.setter
    def offset(self, value: int):
        self._offset = value

    @property
    def next(self) -> Optional[int]:
        return self._next
    
    @next.setter
    def next(self, value: int):
        self._next = value


class FpgaBitStream(ContentElement):

    NAMEre = re.compile(r"^(?P<target>.+)-(?P<date>\d{8}\.\d{2})-(?P<branch>.+)-(?P<commit>.{7}~?)\.bit$")

    def __init__(self, name: str = None, raw_data: bytes = None, filepath: Union[str, Path] = None):
        self._filepath: Optional[Path] = None
        if filepath is not None and name is None and raw_data is None:
            if type(filepath) is str:
                filepath = Path(filepath)
            name: str = filepath.name
            raw_data: bytes = filepath.open('rb').read()
            self._filepath = filepath
        ContentElement.__init__(self, name, raw_data)
        self._target: Optional[str] = None
        self._design: Optional[str] = None
        self._date: Optional[datetime.datetime] = None
        self._truncated: bool = False
        if self._raw_data is not None:
            self._parse_bs_header()

    def _parse_bs_header(self):
        REQ_TYPES = {0x61, 0x62, 0x63, 0x64}
        header: dict = {}
        raw_data: bytes = self._raw_data[:512]
        if raw_data[:len(TRUNCBIT_MAGIC)] == TRUNCBIT_MAGIC and raw_data.find(SYNCWORD) < 512:
            self._design = 'unknown'
            self._target = 'unknown'
            self._date = datetime.datetime.fromtimestamp(self.filepath.stat().st_mtime)
            self._truncated = True
            return
        if raw_data[:len(VIVADO_BIT_HEADER)] != VIVADO_BIT_HEADER:
            raise FileError("invalid bitstream magic")
        raw_data = raw_data[len(VIVADO_BIT_HEADER):]
        while len(raw_data):
            field_type: int = struct.unpack('>BB', raw_data[:2])[0]
            raw_data = raw_data[1:]
            if field_type not in REQ_TYPES:
                break
            field_length: int = struct.unpack('>H', raw_data[:2])[0]
            header[field_type] = raw_data[2:2 + field_length].strip(b'\x00')
            raw_data = raw_data[2 + field_length:]
        header_set = set(header.keys())
        if len(header_set - REQ_TYPES) > 0 or len(header_set) != len(REQ_TYPES):
            raise FileError('failed to parse bistream header')
        self._design = header[97].decode('ascii')
        self._target = header[98].decode('ascii')
        self._date = datetime.datetime.strptime((header[99]+b'-'+header[100]).decode('ascii'), '%Y/%m/%d-%H:%M:%S')
        self._truncated = False
        self._guess_match: Optional[Dict[str, str]] = {}

    def __repr__(self) -> str:
        return f'<FpgaBitStream "{self.name}" for {self.target} {len(self.raw_data)} bytes>'

    @property
    def design(self) -> Optional[str]:
        return self._design

    @property
    def target(self) -> Optional[str]:
        return self._target

    @property
    def date(self) -> Optional[str]:
        return self._date
    
    @property
    def filepath(self) -> Optional[Path]:
        return self._filepath

    @property
    def truncated(self) -> bool:
        return self._truncated

    @property
    def raw_data_truncated(self) -> bytes:
        if self._truncated:
            return self._raw_data
        return self._raw_data[120:]

    @property
    def guess_target(self) -> Optional[MEGA65target]:
        if not self.target:
            return None
        namematch = self._guess_match = self.NAMEre.match(self.filepath.name)
        if not namematch:
            return None
        for target in M65_TARGETS.by_fpga(self.target):
            if target.name == namematch.groupdict()['target'].replace('-', ''):
                return target
        return None

    @property
    def guess_name(self) -> Optional[str]:
        if self._guess_match is None:
            return None
        return 'MEGA65'

    @property
    def guess_version(self) -> Optional[str]:
        if self._guess_match is None:
            return None
        branch: str = self._guess_match['branch']
        if branch == 'develo':
            branch = "Development"
        elif branch.startswith('r-'):
            return f'Release {branch[2:]} {self._guess_match["commit"]}'
        elif '-' in branch:
            try:
                num = int(branch.split('-',1)[0])
            except ValueError:
                num = None
            if num is not None:
                branch = f'Issue #{num}'
        
        return f'{branch} {self._guess_match["date"]} {self._guess_match["commit"]}'

    def print_info(self):
        print(f'\nBITFILE "{self.name}"{" TRUNCATED" if self.truncated else ""}')
        print(f"  Date:   {self.date.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"  Design: {self.design}")
        print(f"  Target: {self.target}")
        print(f"  Size:   {len(self.raw_data)}")
        if M65_TARGETS.by_fpga(self.target):
            print(f"\n  Derived Platforms: {', '.join([x.name for x in M65_TARGETS.by_fpga(self.target)])}")


NAMEre = re.compile(r'[^ -Z[\]^_a-z]+')
class CoreFile:

    header_size = 4096

    def __init__(self, filepath: Optional[Path] = None):
        self._bit_name: str = ''
        self._bit_version: str = ''
        self._bit_target: Optional[MEGA65target] = None

        self._boot_caps: int = 0
        self._boot_flags: int = 0
        self._install_flags: int = 0

        self._bitstream: Optional[FpgaBitStream] = None
        self._erase_list: List[int] = []

        self._core_length: int = 0
        self._core_crc32: int = 0

        self._banner_data: bytes = b''
        self._embed_files: List[EmbeddedFile] = []

        self._erase_list: array = array('B', b'\xff'*16)

        self._filepath: Path = Path('__BUILDER__')
        if filepath:
            self.load_core(filepath)

    @property
    def filepath(self) -> Path:
        return self._filepath

    @filepath.setter
    def filepath(self, value: Path):
        self._filepath = value

    @property
    def bit_name(self) -> str:
        return self._bit_name

    @bit_name.setter
    def bit_name(self, value: Union[bytes, str]):
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._bit_name = NAMEre.sub(' ', value).strip()[:31]

    @property
    def bit_version(self):
        return self._bit_version

    @bit_version.setter
    def bit_version(self, value: Union[bytes, str]):
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._bit_version = NAMEre.sub(' ', value).strip()[:31]
    
    @property
    def bit_target(self) -> Optional[MEGA65target]:
        return self._bit_target

    @bit_target.setter
    def bit_target(self, value: Union[int, bytes, str, MEGA65target]):
        if isinstance(value, MEGA65target):
            self._bit_target = value
            return
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._bit_target = M65_TARGETS.get(value)

    @property
    def core_max_size(self) -> int:
        if self._bit_target:
            return self._bit_target.size * 1024
        return 0

    @property
    def boot_caps(self) -> int:
        return self._boot_caps

    @boot_caps.setter
    def boot_caps(self, value: int):
        self._boot_caps = value

    @property
    def boot_flags(self) -> int:
        return self._boot_flags

    @boot_flags.setter
    def boot_flags(self, value: int):
        self._boot_flags = value

    @property
    def install_flags(self) -> int:
        return self._install_flags

    @install_flags.setter
    def install_flags(self, value: int):
        self._install_flags = value

    @property
    def bitstream(self) -> Optional[FpgaBitStream]:
        return self._bitstream

    @bitstream.setter
    def bitstream(self, value: Optional[FpgaBitStream]):
        self._bitstream = value

    @property
    def core_length(self) -> int:
        return self._core_length
    
    @core_length.setter
    def core_length(self, value: int):
        self._core_length = value

    @property
    def core_crc32(self) -> int:
        return self._core_crc32
    
    @core_crc32.setter
    def core_crc32(self, value: int):
        self._core_crc32 = value

    @property
    def banner_data(self) -> bytes:
        return self._banner_data
    
    @banner_data.setter
    def banner_data(self, value: Optional[bytes]):
        if not value:
            self._banner_data = b''
            return
        if len(value) > BANNER_SIZE:
            raise ValueError("banner data bigger than 32k")
        self._banner_data = value

    @property
    def banner_data_array(self) -> array:
        return array('B', self._banner_data + b'\x00'*(BANNER_SIZE - len(self.banner_data)))

    @property
    def has_banner(self) -> bool:
        return self._banner_data != b''

    @property
    def banner_size(self) -> int:
        return BANNER_SIZE if self.has_banner else 0

    @property
    def embed_files(self) -> List[EmbeddedFile]:
        return self._embed_files

    @property
    def embed_count(self) -> int:
        return len(self._embed_files)

    @property
    def embed_size(self) -> int:
        return sum([x.raw_data_length for x in self._embed_files])

    @property
    def erase_list(self) -> array:
        return self._erase_list

    @property
    def erase_list_str(self) -> str:
        res: List[str] = []
        for x in self.erase_list:
            if x == 0xff:
                break
            res.append(f'${x:02X}')
        return ', '.join(res)

    def find_file(self, name: str) -> Optional[EmbeddedFile]:
        for file in self._embed_files:
            if file.name == name:
                return file
        return None

    def add_file(self, filepath: Union[str, Path]) ->  EmbeddedFile:
        if isinstance(filepath, str):
            filepath: Path = Path(filepath)
        if self.find_file(filepath.name):
            raise FileError('duplicate filename')
        try:
            data = filepath.open('rb').read()
        except (FileNotFoundError, IOError) as err:
            raise FileError(err)
        obj = EmbeddedFile(filepath.name, data)
        if self.embed_size + self.header_size + self.banner_size + obj.raw_data_length > self.core_max_size:
            raise FileError("core size exceeded")
        self._embed_files.append(obj)
        return obj

    def add_fileobj(self, obj: EmbeddedFile):
        self._embed_files.append(obj)

    def add_files(self, files: List[str]):
        for file in files:
            self.add_file(file)

    def remove_file(self, pattern: str) -> int:
        count: int = 0
        new_files: List[EmbeddedFile] = []
        for file in self._embed_files:
            if fnmatch.fnmatch(file.name, pattern):
                count += 1
                continue
            new_files.append(file)
        self._embed_files = new_files
        return count

    def rename_file(self, old: str, new: str) -> bool:
        for file in self._embed_files:
            if file.name == old:
                file.name = new
                return True
        return False

    def generate(self) -> bytes:
        if not self.bitstream or not self.bit_target or not self.bit_name or not self.bit_version:
            raise ValueError("need at least bitstream, target, name and version to build core")

        # calculate full length
        self.core_length = self.core_max_size
        if not self.has_banner:
            if not self.embed_count:
                self.core_length = 4096 + self.bitstream.raw_data_length
            else:
                self.core_length = self.embed_files[-1].next + 40

        buffer: array = array('B', b'\x00' * self.core_length)

        embed_offset: int = 4096 + self.bitstream.raw_data_length if self.embed_count else 0
        struct.pack_into("<16s32s32s32sBBBIIBBBHII104s16s", buffer, 0,
                         CORE_MAGIC,
                         self.bit_name.encode('ascii'), self.bit_version.encode('ascii'),
                         self.bit_target.name.encode('ascii'), self.bit_target.code,
                         1 if self.has_banner else 0, self.embed_count, embed_offset, 0,
                         self.boot_caps, self.boot_flags, self.install_flags, 0,
                         self.core_length, CORE_CRC32_I,
                         b'', b'\xff'*16)

        buffer[4096:4096+self.bitstream.raw_data_length] = array('B', self.bitstream.raw_data)
        buffer[-BANNER_SIZE:] = self.banner_data_array

        for file in self.embed_files:
            file.offset = embed_offset
            file.next = embed_offset + 40 + file.raw_data_length
            struct.pack_into('<II32s', buffer, embed_offset, file.next, file.raw_data_length, file.name.encode('ascii'))
            buffer[embed_offset + 40:file.next] = array('B', file.raw_data)
            embed_offset = file.next

        struct.pack_into('<I', buffer, 0x84, crc32(buffer.tobytes()))

        return buffer.tobytes()

    def load_core(self, filepath: Path):
        self.filepath = filepath
        data: bytes = filepath.open('rb').read()

        self._errors = errors = ErrorHandler()

        res = struct.unpack("<16s32s32s32sBBBIIBBBHII104s16s", data[:256])
        if res[0] != CORE_MAGIC:
            raise FileError("not a Core file, magic mismatch!")

        self.bit_name = res[1]
        self.bit_version = res[2]
        self.bit_target = res[4]
        if self.bit_target is None:
            errors['bit_target'] = f'unknown bit_target code ${res[4]:02X}'
        else:
            btn = zero_string(res[3], 'ascii')
            if self.bit_target.name != btn:
                errors['bit_target'] = f"bit_target name {zero_string(res[3], 'ascii')} does not match ${res[4]:02X}"

        has_banner: bool = res[5] != 0
        if has_banner:
            self.banner_data = data[-BANNER_SIZE:]

        embed_count: int = res[6]
        next_offset: int = res[7]
        # 8 is filler

        self.boot_caps = res[9]
        if M65_CAPS.has_invalid_bits(self.boot_caps):
            errors['boot_caps'] = 'Undefined bits are set'
        self.boot_flags = res[10]
        if M65_CAPS.has_invalid_bits(self.boot_flags):
            errors['boot_flags'] = 'Undefined bits are set'
        elif self.boot_flags & self.boot_caps != self.boot_flags:
            errors['boot_flags'] = 'Flags without Caps'
        self.install_flags = res[11]
        if M65_INST.has_invalid_bits(self.install_flags):
            errors['install_flags'] = 'Undefined bits are set'
        # 12 is filler

        self.core_length = res[13]
        if self.core_length != len(data):
            errors['core_length'] = f'Core length mismatch {len(data)}' if self.core_length > 0 else 'Old bitstream file without length'
        self.core_crc32 = res[14]
        # 15 is filler

        if M65_INST.check('_eraselist', self.install_flags):
            self.erase_list[:] = array('B', res[16])

        if M65_INST.check('factory', self.install_flags) and self.bit_name != FACTORY_NAME:
            errors['bit_name'] = f'Factory core name is not "{FACTORY_NAME}"'

        check_core_crc32: int = crc32(data[:0x84] + b'\xf0\xf0\xf0\xf0' + data[0x88:])
        if self.core_crc32 != check_core_crc32:
            errors['core_crc32'] = f'CRC32 mismatch, should be {check_core_crc32:08X}' if self.core_crc32 != 0 else 'Old bitstream file without CRC32'

        self.bitstream = FpgaBitStream(self.bit_name, data[4096:next_offset] if next_offset else data[4096:])
        if self.bitstream.target != self.bit_target.fpga:
            errors['bitfile_target'] = f'Core {self.bit_target.fpga} != bitstream {self.bitstream.target}'

        while next_offset > 0:
            res = struct.unpack("<II32s", data[next_offset:next_offset+40])
            if res[0] == 0:
                break
            embed = EmbeddedFile(zero_string(res[2], 'ascii'), data[next_offset+40:res[0]], next_offset, res[0])
            if embed.offset + 40 + res[1] != embed.next:
                embed.errors.append('Embed file chaining error')
            self.add_fileobj(embed)
            if embed.name == 'BANNER.M65' and self.banner_data and embed.raw_data != self.banner_data[:embed.raw_data_length]:
                errors['banner'] = 'BANNER.M65 does not match embedded banner data'
            if embed.next > len(data) or embed.next < next_offset:
                errors['embed_eof'] = f'Chaining error at file {self.embed_count}'
                break
            next_offset = embed.next
        if embed_count != self.embed_count:
            errors['embed_count'] = f'embed count mismatch (header: {embed_count})'

    def print_info(self):
        # core info
        print(f'\nCOREFILE "{self.filepath.name}"')
        print(format_error_line(f"@@ Core length: {self.core_length} (file {self.core_length})", self._errors.get('core_length')))
        print(format_error_line(f"@@ Core CRC32:  {self.core_crc32:08X}", self._errors.get('core_crc32')))

        # bitstream 1 info
        print(f"  BITSTREAM 1")
        print(format_error_line(f"  @@ Name:          {self.bit_name}", self._errors.get('bit_name')))
        print(f"    Version:       {self.bit_version}")
        print(format_error_line(f"  @@ Target:        {self.bit_target.code:02X} - {self.bit_target.name} - {self.bit_target.fpga}", [self._errors.get('bithdr_target'), self._errors.get('bitfile_target')]))
        print(format_error_line(f"  @@ Capabilities:  {M65_CAPS.get_active_str(self.boot_caps)}", self._errors.get('boot_caps')))
        print(format_error_line(f"  @@ Active Flags:  {M65_CAPS.get_active_str(self.boot_flags)}", self._errors.get('boot_flags')))
        print(format_error_line(f"  @@ Install Flags: {M65_INST.get_active_str(self.install_flags)}", self._errors.get('install_flags')))
        print(f"    Eraselist:     {'yes - ' + self.erase_list_str if M65_INST.check('_eraselist', self.install_flags) else 'no'}")

        # file info
        print(f"  EMBEDDED FILES")
        print(f"    Has embedded banner: {'yes' if self.has_banner else 'no'}")
        print(format_error_line(f"  @@ File count: {self.embed_count}", self._errors.get('embed_count')))
        embed_next = 0
        for num, embed in enumerate(self.embed_files):
            print(format_error_line(f"    @@ FILE {num:2d}: {embed.name:32s} length {embed.raw_data_length:8d} offset {embed.offset:8d} next {embed.next:8d}", embed.errors))
            embed_next = embed_next
        if self.embed_count:
            print(format_error_line(f"    @@ EOF                                       length        0 offset {embed_next:8d} next        0", self._errors.get('embed_eof')))


class MCSFile:

    def __init__(self, filepath: Optional[Union[str, Path]] = None):
        self._filepath: Path = None
        self._raw_data: bytes = None
        self._offset: int = 0
        if filepath is not None:
            if type(filepath) is str:
                filepath = Path(filepath)
            self.load_mcs(filepath)

    @property
    def filepath(self) -> Path:
        return self._filepath
    
    @property
    def raw_data(self) -> bytes:
        return self._raw_data
    
    @raw_data.setter
    def raw_data(self, data: bytes):
        self._raw_data = data

    @property
    def offset(self) -> int:
        return self._offset
    
    @offset.setter
    def offset(self, offset: int):
        if offset & 0xffff != 0:
            print(f"!Warning offset is not aligned to 16 bit, truncating")
        self._offset = offset & 0xffff0000

    @property
    def filetype(self) -> str:
        if not self._raw_data:
            return 'EMPTY'
        if self._raw_data[:len(CORE_MAGIC)] == CORE_MAGIC:
            return 'M65-Core'
        if self._raw_data[:16] == TRUNCBIT_MAGIC:
            return 'Trunc-Bit'
        return 'UNKNOWN'

    @property
    def corefile(self) -> Optional[CoreFile]:
        if self.filetype != 'M65-Core':
            return None
        obj = CoreFile()
        obj.filepath = self.filepath
        try:
            obj.parse_coredata(self.raw_data)
        except FileError as err:
            print("!failed to interpret MCS content as Corefile: {err}")
            return None
        return obj

    def __repr__(self) -> str:
        return f'<MCSFile "{self.filepath.name}" @{self.offset:08X} {len(self._raw_data)}b {self.filetype}>'

    @staticmethod
    def _calc_checksum(data: array) -> int:
        return (((sum(data) & 0xff) ^ 0xff) + 1) & 0xff

    def load_mcs(self, filepath: Path):
        self._raw_data = b''
        self._offset = 0
        blob: bytes = b''
        linenum: int = 0
        highaddr: int = -1
        nextaddr: int = -1
        for line in filepath.open('rt', encoding="ascii"):
            linenum += 1
            line = line.strip()
            if not line:
                continue

            if line[0] != ':':
                raise FileError("MCS data line does not start with ':'")

            data = array('B', bytes.fromhex(line[1:]))
            if self._calc_checksum(data[:-1]) != data[-1]:
                print(data, self._calc_checksum(data[:-1]))
                raise FileError(f"checksum error in line {linenum}")

            if data[3] not in (0, 1, 4):
                raise FileError(f"unknown record type {data[3]} in line {linenum}")

            if data[3] == 4: # addr offset
                if data[1] != data[2] != 0:
                    raise FileError(f"invalid addr offset record in line {linenum}")
                newhigh = (data[4] << 8) + data[5]
                if highaddr != -1 and newhigh != highaddr + 1:
                    raise FileError(f"high address discontinuity error in line {linenum:08d}: {newhigh} != {highaddr + 1}")
                highaddr = newhigh
                nextaddr = 0
                self._raw_data += blob
                blob = b''
                continue
            
            if data[3] == 1: # end marker
                self._raw_data += blob
                break

            if highaddr < 0 or nextaddr < 0:
                raise FileError(f"unexpected nextaddr in line {linenum}")
            
            thisaddr = (data[1] << 8) + data[2]
            if nextaddr != thisaddr:
                raise FileError(f"address discontinuity error in line {linenum:08d}: {thisaddr} != {nextaddr}")
            blob += data[4:-1]
            nextaddr = thisaddr + data[0]

        self._filepath = filepath

    def print_info(self):
        print(f'\nMCSFILE "{self.filepath.name}"')
        print(f"  Content: {self.filetype}")
        print(f"  Offset:  0x{self.offset:08X}")
        print(f"  Size:    {len(self.raw_data)}")
        core = self.corefile
        if core:
            print("\nOpened MEGA65 Corefile found inside MCS file")
            core.print_info()

    def save_data(self, path: Path):
        path.open('rb').write(self._raw_data)

    def write_file(self, path: Path):
        highaddr: int = (self.offset >> 16) & 0xffff
        nextaddr: int = 0
        with path.open('wt', encoding='ascii', buffering=131072) as fp:
            try:
                data: bytes = array('B', self.raw_data)
                datalen: int = len(data)
                offset: int = 0
                while offset < datalen:
                    if nextaddr == 0:
                        checksum = (((2 + 4 + (highaddr & 0xff) + ((highaddr >> 8) & 0xff)) ^ 0xff) + 1) & 0xff
                        line = f':02000004{highaddr:04X}{checksum:02X}\n'
                        fp.write(line)
                    linelen = min(16, datalen - offset)
                    checksum = (((linelen + (nextaddr & 0xff) + ((nextaddr >> 8) & 0xff) + sum(data[offset:offset+linelen])) ^ 0xff) + 1) & 0xff
                    line = ':' + (struct.pack('>BHB', linelen, nextaddr, 0) + data[offset:offset+linelen].tobytes() + bytes([checksum])).hex().upper() + '\n'
                    fp.write(line)
                    offset += linelen
                    nextaddr = nextaddr + linelen
                    if (nextaddr >> 16) > 0:
                        nextaddr = 0
                        highaddr += 1
                fp.write(':00000001FF\n')
            except IOError as err:
                print(f"!Error while writing MCS file: {err}")

def open_file(filepath: Union[str, Path]) -> Optional[Union[CoreFile, MCSFile, FpgaBitStream]]:
    if isinstance(filepath, str):
        filepath = Path(filepath)

    fileobj: Union[CoreFile, MCSFile, FpgaBitStream] = None
    try:
        header = filepath.open('rb').read(256)
    except (FileNotFoundError, IOError) as err:
        print(f"!Failed to open file: {err}")
        return None

    if header[:9] == b':02000004':
        try:
            fileobj = MCSFile(filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            print('!Failed to load MCSFile "{filepath.name}": {err}')
            return None
        else:
            print(f'Opened MCS file "{filepath.name}"')

    elif header[:len(CORE_MAGIC)] == CORE_MAGIC:
        try:
            fileobj = CoreFile(filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            print(f'!Failed to load Corefile "{filepath.name}": {err}')
            return None
        else:
            print(f'Opened Corefile file "{filepath.name}"')

    elif (header[:len(VIVADO_BIT_HEADER)] == VIVADO_BIT_HEADER or
          (header[:len(TRUNCBIT_MAGIC)] == TRUNCBIT_MAGIC and header.find(SYNCWORD) < 512)):
        try:
            fileobj = FpgaBitStream(filepath=filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            print(f'!Failed to load FPGA Bitstream "{filepath.name}": {err}')
            return None
        else:
            print(f'Opened Bitstream file "{filepath.name}"')
    else:
        print(f"!Found unknown file header, can't work with \"{filepath.name}\"")
        return None

    return fileobj


def verify_file(args: argparse.Namespace) -> int:
    fileobj = open_file(args.verify)
    if fileobj:
        fileobj.print_info()
        return 0
    return 1


def build_file(args: argparse.Namespace) -> int:
    if args.bit is None:
        print("!Please provide a bitstream file using --bit/-b")
        return 1

    filepath: Path = Path(args.build)
    if not args.force and filepath.exists():
        print("!Target corefile exists, use --force to overwrite")
        return 1

    bits = [x for x in zip_longest(args.bit, args.name or [], args.version or [])]
    if len(bits) != 1:
        print("!Build can currently handle only one bitstream")
        return 1

    core = CoreFile()

    bitobj: FpgaBitStream = open_file(bits[0][0])
    if bitobj is None or not isinstance(bitobj, FpgaBitStream) or bitobj.truncated:
        print("!Build requires a full Bitstream to work on.")
        return 1

    core.bitstream = bitobj

    if args.target is None:
        target = bitobj.guess_target
        if target:
            print(f"Target guessed to be {target.name}/${target.code:02X}")
    else:
        target = M65_TARGETS.get(args.target)
    
    if target is None:
        print("!Failed to guess target, use --target/-t to specify")
        return 1

    name = bits[0][1]
    if not name:
        name = bitobj.guess_name
        if name:
            print(f'Name guessed to be "{name}"')
    if not name:
        print("!Please provide a name for the core using --name/-n")
        return 1

    version = bits[0][2]
    if not version:
        version = bitobj.guess_version
        if version:
            print(f'Version guessed to be "{version}"')
    if not version:
        print("!Please provide a version for the core using --version/-v")

    core.bit_target = target
    core.bit_name = name
    core.bit_version = version

    if args.caps:
        core.boot_caps, errs = M65_CAPS.parse_str(args.caps)
        if errs:
            for err in errs:
                print(err)
            print(f"!invalid caps found")
            return 1

    if args.flags:
        core.boot_flags, errs = M65_CAPS.parse_str(args.caps)
        if errs:
            for err in errs:
                print(f"!{err}")
            print(f"!invalid flags found")
            return 1

    if args.install:
        core.install_flags, errs = M65_CAPS.parse_str(args.caps)
        if errs:
            for err in errs:
                print(f"!{err}")
            print(f"!invalid install flags found")
            return 1

    for file in (args.add_files or []):
        filepath = Path(file)
        try:
            obj = core.add_file(filepath)
        except FileError as err:
            print(f'!Failed to add "{filepath.name}": {err}')
        else:
            print(f"*embedded \"{filepath.name}\"")
            if filepath.name == 'BANNER.M65':
                core.banner_data = obj.raw_data
                print(f"*banner automatically set")            

    if args.set_banner:
        if core.has_banner:
            print("!Banner already set by BANNER.M65 file")
            return 1
        try:
            core.banner_data = open(args.set_banner, 'rb').read()
        except (FileNotFoundError, IOError, ValueError) as err:
            print("!Error while setting banner: {err}")
            return 1

    core.filepath = Path(args.build)
    core.filepath.open('wb').write(core.generate())

    return 1

def extract_files(args: argparse.Namespace) -> int:
    filepath: Path = Path(args.extract)
    destpath: Path
    if args.extract_path is None:
        destpath = filepath.parent.joinpath(sanitize_filename(filepath.stem))
    else:
        destpath = Path(args.extract_path)
    if destpath.exists() and not destpath.is_dir():
        print("!Destination exists and is not a directory.")
        return 1
    if not destpath.exists():
        try:
            destpath.mkdir()
        except FileNotFoundError:
            print("!Failed to create target directory.")
            return 1
    print(f"Extracting to {destpath.absolute()}")

    fileobj = open_file(filepath)
    if fileobj is None:
        return 1

    if isinstance(fileobj, FpgaBitStream):
        print("!Can't extract files from a bitstream, abort.")
        return 1

    if isinstance(fileobj, MCSFile):
        if fileobj.filetype == "Trunc-Bit":
            destfile = destpath.joinpath(sanitize_filename(filepath.stem + '.bit'))
            try:
                fileobj.save_data(destfile)
            except (IOError, OSError) as err:
                print(f"!Failed to save bitstream as {destfile.name}: {err}")
                return 1
            print(f"Saved truncated bitstream as {destfile.name}")
            return 0
        if fileobj.filetype != "M65-Core":
            destfile = destpath.joinpath(sanitize_filename(f'unknown_{filepath.stem}.dat'))
            try:
                fileobj.save_data(destfile)
            except (IOError, OSError) as err:
                print(f"!Failed to save content as {destfile.name}: {err}")
                return 1
            print(f"Saved unknown content as {destfile.name}")
            return 0
        print(f"Found MEGA65 Corefile stored in MCS")
        fileobj = fileobj.corefile

    if isinstance(fileobj, CoreFile):
        bitnum: str = 'one' if fileobj.bitstream else 'no'
        print(f"Found {bitnum} bitstream and {fileobj.embed_count} embedded files")
        errors: int = 0
        if fileobj.bitstream:
            destfile = destpath.joinpath(sanitize_filename(f"{fileobj.bit_target_name}-{fileobj.bit_version}.bit".replace(' ', '_')))
            try:
                fileobj.bitstream.save_data(destfile)
            except (IOError, OSError) as err:
                print(f"!Failed to save bitstream as {destfile.name}: {err}")
                errors += 1
            else:
                print(f"Saved bitstream as {destfile.name}")
        for embed in fileobj.embedded_files:
            destfile = destpath.joinpath(sanitize_filename(embed.name))
            try:
                embed.save_data(destfile)
            except (IOError, OSError) as err:
                print(f"!Failed to save embedded as {destfile.name}: {err}")
                errors += 1
            else:
                print(f"Saved embedded file {destfile.name}")
        return errors

    return 0

def convert_files(args: argparse.Namespace) -> int:

    def _return_if_exists(path) -> bool:
        if path.exists() and not args.force:
            print("!Target file exists, use --force to overwrite anyway.")
            return True
        return False

    if args.offset is None:
        args.offset = 0
    elif args.offset.startswith('S'):
        if args.target is None:
            print("\nOffset in slot format requires --target to be set!")
            return 1
        args.offset = args.target.size * int(args.offset[1:]) * 1024
    else:
        args.offset = int(args.offset)
    print(f'0x{args.offset:08x}')

    path_from: Path = Path(args.convert[0])
    path_to: Path = Path(args.convert[1])

    if _return_if_exists(path_to):
        return 1

    fileobj = open_file(path_from)
    if fileobj is None:
        return 1

    if isinstance(fileobj, FpgaBitStream):
        if path_to.suffix.lower() == '.cor':
            print(f"!Please use --build action to create a Corefile from a FPGA Bitstream.")
            return 1
        if path_to.suffix.lower() != '.mcs':
            print(f"!Invalid conversion target {path_to.suffix.lower()[1:]} for FPGA Bitstream")
            return 1
        mcs: MCSFile = MCSFile()
        # bit2mcs does remove the bitstream header... so we do the same...
        mcs.raw_data = fileobj.raw_data_truncated
        mcs.offset = args.offset
        try:
            mcs.write_file(path_to)
        except (IOError, OSError) as err:
            print(f'!Failed to write "{path_to.name}": {err}')
            return 1
        print(f'Converted bitstream to MCS "{path_to.name}"')
        return 0

    if isinstance(fileobj, CoreFile):
        if path_to.suffix.lower() == '.mcs':
            mcs: MCSFile = MCSFile()
            # bit2mcs does remove the bitstream header... so we do the same...
            mcs.raw_data = fileobj.raw_data
            mcs.offset = args.offset
            try:
                mcs.write_file(path_to)
            except (IOError, OSError) as err:
                print(f'!Failed to write "{path_to.name}": {err}')
                return 1
            print(f'Converted Corefile to MCS "{path_to.name}"')
            return 0
        if path_to.suffix.lower() == '.bit':
            # we just save the bitstream...
            try:
                fileobj.bitstream.save_data(path_to)
            except (IOError, OSError) as err:
                print(f'!Failed to write "{path_to.name}": {err}')
                return 1
            print(f'Converted Corefile to FPGA Bitstream "{path_to.name}"')
            return 0
        print(f'!Invalid conversion target {path_to.suffix.lower()[1:]} for Corefile')
        return 1

    if isinstance(fileobj, MCSFile):
        if fileobj.filetype == 'M65-Core':
            if path_to.suffix.lower() in ('.bit', '.mcs'):
                print("!MCS contains MEGA65 Corefile, changing suffix to .cor")
                path_to = path_to.with_suffix('.cor')
            target = 'MEGA65 Corefile'
        elif fileobj.filetype == 'Trunc-Bit':
            if path_to.suffix.lower() in ('.mcs', '.cor'):
                print("!MCS contains truncated FPGA Bitstream, changing suffix to .bit")
                path_to = path_to.with_suffix('.bit')
            target = 'FPGA Bitstream'
        else:
            if path_to.suffix.lower() in ('.mcs', '.cor', '.bit'):
                print("!MCS contains unknown data, changing suffix to .dat")
                path_to = path_to.with_suffix('.dat')
            target = 'unknown data'

        if _return_if_exists(path_to):
            return 1
        try:
            path_to.open('wb').write(fileobj.raw_data)
        except (IOError, OSError) as err:
            print(f'!Failed to write "{path_to.name}": {err}')
            return 1
        print(f'Converted MCS File to {target} "{path_to.name}"')
        return 0

    return 1


class CustomHelpFormatter(argparse.HelpFormatter):

    def _fill_text(self, text, width, indent):
        import textwrap
        result = []
        print("text", repr(text))
        for paragraph in re.split('\n\n\n+[ \t]*', text):
            print("para:", repr(paragraph))
            paragraph = self._whitespace_matcher.sub(' ', paragraph).strip()
            result.append(textwrap.fill(paragraph, width,
                                        initial_indent=indent,
                                        subsequent_indent=indent))
        return '\n\n'.join(result)


def main():
    global DO_COLOR, WIDTH

    parser = argparse.ArgumentParser("coretool", formatter_class=CustomHelpFormatter,
                                     description=f"{CBOLD if DO_COLOR else ''}!!!UNFINISHED!!! STILL IN DEVELOPMENT!!!{CST if DO_COLOR else ''}\n\n\nMEGA65 Corefile utility",
                                     epilog=f"""{CBOLD if DO_COLOR else ''}WARNING:{CST if DO_COLOR else ''} if you are not a developer, this tool is probably not for you!\n\n
                                     This tool allows the construction, modification and verification of MEGA65 core files, as well as the conversion between Corefile,
                                     FPGA Bitstream and the Intel MCS-86 fileformat (also used by Vivado).\n\n
                                     A Corefile is mainly used to flash bistreams in a defined way into your MEGA65 mainboard. This is done with the MEGAFLASH utility,
                                     which you can bring up by holding down NO-SCROLL and then powering on your mega65.\n\n
                                     {CBOLD if DO_COLOR else ''}!!!UNFINISHED!!! STILL IN DEVELOPMENT!!!{CST if DO_COLOR else ''}""")
    actions = parser.add_argument_group("Action", "The main function that is executed")
    actions_ex = actions.add_mutually_exclusive_group(required=True)
    actions_ex.add_argument('--verify', '-V', metavar="FILE", type=str, help="Display information about a file.")
    actions_ex.add_argument('--build', '-B', metavar="COREFILE", type=str, help="Build a new corefile.")
    actions_ex.add_argument('--modify', '-M', metavar="COREFILE", type=str, help="Modify an existing corefile.")
    actions_ex.add_argument('--extract', '-X', metavar="COREFILE", type=str,
                            help="""Extract all files from a corefile and place them into a path with the name of the corefile minus it's extension. Use --extract-path
                            to specify an alternative path.""")
    actions_ex.add_argument('--convert', '-C', metavar="FILE", type=str, nargs=2,
                            help="Convert one type of file into the other. Note: only a few direct conversions are supported, but you can always fallback to extract/build  instead.")

    group = parser.add_argument_group('Generic', 'Generic options')
    group.add_argument('--force', '-F', action="store_true", help="Force overwriting existing files.")
    group.add_argument('--offset', metavar="OFFSET", type=str, help="Offset to be set when converting a corefile to the MCS format. Defaults to 0.")
    group.add_argument('--extract-path', metavar="PATH", type=str, help="Target path for the extract action.")
    coloropt = group.add_mutually_exclusive_group()
    coloropt.add_argument('--color', action="store_true", default=None, help="Enable Color on output(autodetect).")
    coloropt.add_argument('--no-color', action="store_false", default=None, help="Disable Color on output (autodetect).")
    group.add_argument('--width', type=int, help="Terminal width (autodetected if possible).")

    group = parser.add_argument_group('Bitstream',
                                      """The bitstream is the FPGA programming information that makes your MEGA65 behave a certain way. You set the name and the version
                                      displayed in MEGAFLASH with the respective options. The target platform is derived from the provided bitstream content and name, but
                                      in case of ambiguity the tool will ask you to provide the target.""")
    group.add_argument('--target', '-t', metavar="TARGET", type=str, help="Target platform name (list to show allowed values).")
    group.add_argument('--bit', '-b', metavar="BITPATH", type=str, action="append", help="Path to the bitstream to be added into the corefile.")
    group.add_argument('--name', '-n', metavar="NAME", type=str, action="append", help="Sets the display name for the bitstream.")
    group.add_argument('--version', '-v', metavar="VERSION", type=str, action="append", help="Sets the display version of the bitstream.")

    group = parser.add_argument_group('Corefile flags',
                                      """The core capabilities define special handling through MEGAFLASH on system startup. It is divided in two parts: the capabilities
                                      define which of the capabilities are supported by this core, the flags define which of those supported capabilities are set by
                                      default. You can use MEGAFLASH to change then inside the system (only flags in the capability set can be changed!).\n\n
                                      Note: if multiple core slots have the same flag set, the core in the slot  with the lowest number wins.\n\n
                                      The install flags handle special core installation cases. With this a core can be marked as a valid slot 0 core and certain security
                                      options can be disabled or the core might even be installed automatically.""")
    group.add_argument('--caps', '-c', metavar="CAPS", type=str, help="Set capabilities (list to show allowed values)")
    group.add_argument('--flags', '-f', metavar="CAPS", type=str, help="Set active flags (list to show allowed values)")
    group.add_argument('--install', '-i', metavar="INST", type=str, help="Set install flags (list to show allowed values)")

    group = parser.add_argument_group('Embedded files',
                                      """It is possible to embed files into the core, right after the bitstream. This are used by the Fdisk utilility to populate the SDcard
                                      after formatting, and it allows to add a BANNER.M65 to a special place, so the booting core can access it more quickly from there.""")
    group.add_argument('--set-banner', metavar="FILE", type=str, help="Add banner file (<32KB) at the end of the corefile. Note: this is not added as an embedded file.")
    group.add_argument('--add-files', metavar="FILE", type=str, nargs="+", help="List of files to add after the bitstream. Note: a file named \"BANNER.M65\" will be automatically set as banner.")
    group.add_argument('--remove-files', metavar="FILE", type=str, nargs="+", help="(Modify) List of files to remove from the corefile. You can use glob patterns (escape!) or the special keyword ALL (caps!).")
    group.add_argument('--rename-file', metavar="FILE", type=str, nargs=2, action="append", help="(Modify) Rename file found inside the corefile.")

    args = parser.parse_args()
    print(args)
    #print(os.get_terminal_size())

    if args.color is not None:
        DO_COLOR = args.color

    if args.width:
        WIDTH = args.width
    else:
        WIDTH = shutil.get_terminal_size().columns - 2

    # check if some parameters are unclear and we need to print a list of valid options
    did_list: bool = False
    if args.caps == 'list' or args.flags == 'list':
        print("\nAllowed capabilities (list multiple separated by comma):")
        print(M65_CAPS.get_help(indent='    '))
        did_list = True
    
    if args.install == 'list':
        print("\nAllowed install flags (list multiple separated by comma):")
        print(M65_INST.get_help(indent='    '))
        did_list = True

    if args.target == 'list':
        print("\nRecognized MEGA65 target specification:")
        print(M65_TARGETS.get_help(indent='    '))
        did_list = True
    args.target = M65_TARGETS.by_name(args.target)
    
    if did_list:
        print()
        sys.exit(0)

    # do the actions
    if args.verify is not None:
        sys.exit(verify_file(args))

    if args.build:
        sys.exit(build_file(args))

    if args.convert is not None:
        sys.exit(convert_files(args))  

    if args.extract is not None:
        sys.exit(extract_files(args))

if __name__ == '__main__':
    main()
