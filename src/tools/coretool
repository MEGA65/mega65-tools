#!/usr/bin/python

import sys
if sys.version_info < (3, 8):
    sys.exit("This tool requires python 3.8 or later!")

import os
import argparse
import struct
import datetime
import re
import shutil
import fnmatch
import logging
import json
from pathlib import Path
from array import array
from binascii import crc32
from itertools import zip_longest
from typing import Optional, Union, List, Tuple, Dict, Generator
from dataclasses import dataclass

log = logging.getLogger("coretool")

##
## CONSTANTS
##
LOG_FORMAT = '[%(asctime)-19.19s %(levelname)-4.4s] %(message)s'

CORE_MAGIC: bytes = b'MEGA65BITSTREAM0'
CORE_CRC32: bytes = b'\xf0\xf0\xf0\xf0'
CORE_CRC32_I: int = 0xf0f0f0f0
BANNER_SIZE: int = 32768
FACTORY_NAME: str = 'MEGA65'

VIVADO_BIT_HEADER: bytes = b'\x00\x09\x0f\xf0\x0f\xf0\x0f\xf0\x0f\xf0\x00\x00\x01'
# old bit2mcs removes the vivado header from the bitstream before writing it into the MCS...
TRUNCBIT_MAGIC: bytes = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'
SYNCWORD: bytes = b'\xaa\x99\x55\x66'
FLASHSECTOR: int = 64*1024


##
## Utility Functions
##
def zero_string(value: bytes, encoding: str) -> str:
    """
    converts bytes into str using encoding.
    will cut string at the first zero byte.
    """
    i = value.find(b'\x00')
    if i:
        value = value[:i]
    return value.decode(encoding)


NOFILECHARre = re.compile(r'[^a-zA-Z0-9._~-]')
def sanitize_filename(value: str) -> Path:
    return Path(NOFILECHARre.sub('_', value))


def supports_color():
    """
    Returns True if the running system's terminal supports color, and False
    otherwise.
    """
    plat = sys.platform
    supported_platform = plat != 'Pocket PC' and (plat != 'win32' or 'ANSICON' in os.environ)
    # isatty is not always implemented, #6223.
    is_a_tty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    return supported_platform and is_a_tty


def RGB(red: Optional[int] = None, green: Optional[int] = None, blue: Optional[int] = None, bg: bool = False, bold: bool = False):
    if not bg and red is not None and green is not None and blue is not None:
        return f'\u001b[{"1;" if bold else ""}38;2;{red};{green};{blue}m'
    elif bg and red is not None and green is not None and blue is not None:
        return f'\u001b[{"1;" if bold else ""}48;2;{red};{green};{blue}m'
    elif red is None and green is None and blue is None:
        return f'\u001b[0{";1" if bold else ""}m'


DO_COLOR: bool = supports_color()
WIDTH: int = 98

CST = RGB()
COK = RGB(0,255,0)
CER = RGB(255,0,0)
CBOLD = RGB(bold=True)

CHAR_CHECK: str = '\u2714'
CHAR_CROSS: str = '\u2717'
CHAR_ERROR: str = '\u2717'

def format_error_line(msg: str, error: Optional[Union[str, List[str]]] = None):
    global DO_COLOR, WIDTH

    iserror: bool = False
    the_error: str = ''
    the_error_base: str = ''
    if isinstance(error, list):
        iserror = False
        for err in error:
            if err:
                iserror = True
                the_error = err
                break
    elif isinstance(error, str):
        iserror = True
        the_error = error

    msg_base: str = msg.replace('@@', CHAR_CHECK if not iserror else CHAR_CROSS)
    if DO_COLOR:
        msg = msg.replace('@@', COK+CHAR_CHECK+CST if not iserror else CER+CHAR_CROSS+CST)
    else:
        msg = msg_base

    if iserror:
        msg += '  '
        msg_base += '  '
        the_error_base = CHAR_ERROR + ' ' + the_error
        if DO_COLOR:
            the_error = CER+CHAR_ERROR+CST + ' ' + the_error
        else:
            the_error = the_error_base
        if WIDTH - len(msg_base) < len(the_error_base):
            msg += '\n' + ' ' * (WIDTH - len(the_error_base)) + the_error
        else:
            msg += ' ' * (WIDTH - len(msg_base) - len(the_error_base)) + the_error
    return msg


class FileError(Exception): pass


class ErrorHandler:

    def __init__(self):
        self._errors: Dict[str: List[str]] = {}

    def __setitem__(self, key: str, value: str):
        self._errors.setdefault(key, []).append(value)
    
    def __getitem__(self, key: str) -> List[str]:
        return self._errors[key]

    def __len__(self) -> int:
        return len(self._errors)

    def get(self, key: str) -> List[str]:
        return self._errors.get(key, [])


@dataclass(frozen=True)
class MEGA65target:
    name: str
    code: int
    size: int
    fpga: int


class MEGA65targets:

    targets = [
        MEGA65target("mega65r1",        0x01, 8192, "7a200tfbg484"),
        MEGA65target("mega65r2",        0x02, 4096, "7a100tcsg324"),
        MEGA65target("mega65r3",        0x03, 8192, "7a200tfbg484"),
        MEGA65target("mega65r4",        0x04, 8192, "7a200tfbg484"),
        MEGA65target("mega65r5",        0x05, 8192, "7a200tfbg484"),
        MEGA65target("mega65r6",        0x06, 8192, "7a200tfbg484"),
        MEGA65target("megaphoner1",     0x21, 4096, "7a100tcsg324"),
        MEGA65target("nexys4",          0x40, 4096, "7a100tcsg324"),
        MEGA65target("nexys4ddr",       0x41, 4096, "7a100tcsg324"),
        MEGA65target("nexys4ddrwidget", 0x42, 4096, "7a100tcsg324"),
        MEGA65target("wukonga100t",     0xFD, 4096, "7a100tcsg324")
    ]

    def __init__(self):
        self._by_name: dict = {}
        self._by_code: dict = {}
        self._by_fpga: dict = {}
        for t in self.targets:
            self._by_name[t.name] = t
            self._by_code[t.code] = t
            self._by_fpga.setdefault(t.fpga, []).append(t)

    def by_name(self, key: str) -> MEGA65target:
        return self._by_name.get(key, None)

    def by_code(self, key: int) -> MEGA65target:
        return self._by_code.get(key, None)

    def by_fpga(self, key: str) -> List[MEGA65target]:
        return self._by_fpga.get(key, None)

    def get(self, key: any) -> Union[MEGA65target, List[MEGA65target]]:
        if type(key) is int:
            return self._by_code.get(key, None)
        return self._by_name.get(key, self._by_fpga.get(key, None))
    
    def get_help(self, indent: str = '') -> str:
        lines = [('Targetname', 'Code - FPGA Part'), ('===========', '===================')] + [(f"{x.name}", f"0x{x.code:02X} - {x.fpga}") for x in self.targets]
        fmtlen = max([len(x[0]) for x in lines])
        lines = [(x[0], ' '*(fmtlen - len(x[0])), x[1]) for x in lines]
        return '\n'.join([f"{indent}{x[0]} {x[1]}{x[2]}" for x in lines])


class MEGA65flags:

    _name = 'key'

    def __init__(self):
        self.flag2name = {x: y[0] for x, y in self._options.items()}
        self.name2flag = {y[0]: x for x, y in self._options.items()}
        self.helptext = [f'{x[0]}: {x[1]}' for x in self._options.values() if x[0][0] != '_']
        self.ok_mask = 0
        for x in self._options:
            self.ok_mask |= x
        self.bad_mask = 0xff ^ self.ok_mask

    def get(self, key: str) -> int:
        return self.name2flag.get(key, 0)
    
    def match(self, key: str) -> Optional[str]:
        res = None
        for name in self.name2flag:
            if name.startswith(key):
                if res is not None:
                    return None
                res = name
        return res

    def parse_str(self, value: str) -> Tuple[int, List[str]]:
        errors: List[str] = []
        flag: int = 0
        for key in re.split(r',\s*', value):
            if not key or key.lower() == 'none':
                continue
            if key[0] == '_':
                errors.append(f'hidden {self._name} "{key}"')
                continue
            name: str = self.match(key.lower())
            if name is None:
                errors.append(f'unknown {self._name} "{key}"')
                continue
            flag |= self.get(name)
        return flag, errors

    def get_options(self) -> List[str]:
        return [x for x in self.name2flag.keys() if x[0] != '_']

    def get_active(self, value: int) -> List[str]:
        return [y for x, y in self.flag2name.items() if value & x]
    
    def get_active_str(self, value: int, join_str: str = ', ', empty_str: str = 'none') -> str:
        active = self.get_active(value)
        if not active:
            return empty_str
        return join_str.join([x for x in active if x[0] != '_'])

    def has_invalid_bits(self, value: int) -> bool:
        return (value & self.bad_mask) != 0

    def make_valid(self, value: int) -> bool:
        return value & self.ok_mask

    def check(self, key: str, value: int) -> bool:
        if key not in self.name2flag:
            raise KeyError(f"unknown flag key '{key}'")
        return (value & self.name2flag[key]) != 0
    
    def get_help(self, indent: str = '') -> str:
        return '\n'.join([indent + x for x in self.helptext])

class MEGA65capflags(MEGA65flags):

    _name = 'capability'

    _options = {
        0b10000000: ('default', 'Core is booted as the default core.'),
        0b00000001: ('c64cart', 'Core can handle C64 cartridge, and is started if one is detected.'),
        0b00000010: ('c128cart', 'Core can handle C128 cartridge, and is started if one is detected.'),
        0b00000100: ('m65cart', 'Core can handle M65 cartridge, and is started if one is detected.'),
    }


class MEGA65instflags(MEGA65flags):

    _name = 'install flag'

    _options = {
        0b00000001: ('factory', 'Is suited as SLOT0 FACTORY CORE'),
        0b00000010: ('auto', 'Skips security questions (factory)'),
        0b01000000: ('_eraselist', 'Has eraslist embedded'),
        0b10000000: ('force', 'Is automatically installed by MEGAFLASH (factory)'),
    }


M65_TARGETS = MEGA65targets()
M65_CAPS = MEGA65capflags()
M65_INST = MEGA65instflags()


class ContentElement:

    def __init__(self, name: str, raw_data: bytes):
        self._name: str = name
        self._raw_data: bytes = raw_data

    @property
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, value: str):
        self._name = value

    @property
    def raw_data(self) -> bytes:
        return self._raw_data

    @raw_data.setter
    def raw_data(self, value: bytes):
        self._raw_data = value

    @property
    def raw_data_length(self) -> int:
        return len(self._raw_data) if self._raw_data else 0

    def __repr__(self) -> str:
        return f'<ContentElement "{self.name}" {len(self.raw_data)} bytes>'
    
    def save_data(self, path: Path):
        path.open('wb').write(self._raw_data)


class EmbeddedFile(ContentElement):

    def __init__(self, name: str, raw_data: bytes, offset: Optional[int] = None, next: Optional[int] = None):
        ContentElement.__init__(self, name, raw_data)
        self._offset: Optional[int] = offset
        self._next: Optional[int] = next
        self.errors: List[Optional[str]] = []
    
    @property
    def offset(self) -> Optional[int]:
        return self._offset
    
    @offset.setter
    def offset(self, value: int):
        self._offset = value

    @property
    def next(self) -> Optional[int]:
        return self._next
    
    @next.setter
    def next(self, value: int):
        self._next = value


class FpgaBitStream(ContentElement):

    NAMEre = re.compile(r"^(?P<target>.+)-(?P<date>\d{8}\.\d{2})-(?P<branch>.+)-(?P<commit>.{7}~?)\.bit$")

    def __init__(self, name: str = None, raw_data: bytes = None, filepath: Union[str, Path] = None):
        ContentElement.__init__(self, name or '__UNKNOWN__', raw_data or b'')
        self._filepath: Optional[Path] = None
        self._target: Optional[str] = None
        self._design: Optional[str] = None
        self._date: Optional[datetime.datetime] = None
        self._truncated: bool = False
        if filepath is not None:
            self.from_file(filepath)
        elif raw_data is not None:
            self._parse_bs_header()

    def from_file(self, filepath: Path):
        self.name = filepath.name
        self.raw_data = filepath.open('rb').read()
        self._filepath = filepath
        self._parse_bs_header()

    def _parse_bs_header(self):
        REQ_TYPES = {0x61, 0x62, 0x63, 0x64}
        header: dict = {}
        raw_data: bytes = self._raw_data[:512]
        if raw_data[:len(TRUNCBIT_MAGIC)] == TRUNCBIT_MAGIC and raw_data.find(SYNCWORD) < 512:
            self._design = 'unknown'
            self._target = 'unknown'
            self._date = datetime.datetime.fromtimestamp(self.filepath.stat().st_mtime)
            self._truncated = True
            return
        if raw_data[:len(VIVADO_BIT_HEADER)] != VIVADO_BIT_HEADER:
            raise FileError("invalid bitstream magic")
        raw_data = raw_data[len(VIVADO_BIT_HEADER):]
        while len(raw_data):
            field_type: int = struct.unpack('>BB', raw_data[:2])[0]
            raw_data = raw_data[1:]
            if field_type not in REQ_TYPES:
                break
            field_length: int = struct.unpack('>H', raw_data[:2])[0]
            header[field_type] = raw_data[2:2 + field_length].strip(b'\x00')
            raw_data = raw_data[2 + field_length:]
        header_set = set(header.keys())
        if len(header_set - REQ_TYPES) > 0 or len(header_set) != len(REQ_TYPES):
            raise FileError('failed to parse bistream header')
        self._design = header[97].decode('ascii')
        self._target = header[98].decode('ascii')
        self._date = datetime.datetime.strptime((header[99]+b'-'+header[100]).decode('ascii'), '%Y/%m/%d-%H:%M:%S')
        self._truncated = False
        self._guess_match: Optional[Dict[str, str]] = None

    def __repr__(self) -> str:
        return f'<FpgaBitStream "{self.name}" for {self.target} {len(self.raw_data)} bytes>'

    @property
    def design(self) -> Optional[str]:
        return self._design

    @property
    def target(self) -> Optional[str]:
        return self._target

    @property
    def date(self) -> Optional[str]:
        return self._date
    
    @property
    def filepath(self) -> Optional[Path]:
        return self._filepath

    @property
    def is_truncated(self) -> bool:
        return self._truncated

    @property
    def raw_data_truncated(self) -> bytes:
        if self._truncated:
            return self._raw_data
        return self._raw_data[120:]

    @property
    def guess_match(self) -> Optional[dict]:
        if self._guess_match is not None:
            return self._guess_match
        namematch = self.NAMEre.match(self.filepath.name)
        if not namematch:
            return None
        self._guess_match = namematch.groupdict()
        return self._guess_match

    @property
    def guess_target(self) -> Optional[MEGA65target]:
        if not self.target:
            return None
        guess = self.guess_match
        for target in M65_TARGETS.by_fpga(self.target):
            if target.name == guess['target'].replace('-', ''):
                return target
        return None

    @property
    def guess_name(self) -> Optional[str]:
        if self.guess_match is None:
            return None
        return 'MEGA65'

    @property
    def guess_version(self) -> Optional[str]:
        if self.guess_match is None:
            return None
        branch: str = self.guess_match['branch']
        if branch == 'develo':
            branch = "Development"
        elif branch.startswith('r-'):
            return f'Release {branch[2:]} {self.guess_match["commit"]}'
        elif '-' in branch:
            try:
                num = int(branch.split('-',1)[0])
            except ValueError:
                num = None
            if num is not None:
                branch = f'Issue #{num}'
        
        return f'{branch} {self.guess_match["date"]} {self.guess_match["commit"]}'

    def print_info(self):
        print(f'\nBITFILE "{self.name}"{" TRUNCATED" if self.is_truncated else ""}')
        print(f"  Date:   {self.date.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"  Design: {self.design}")
        print(f"  Target: {self.target}")
        print(f"  Size:   {len(self.raw_data)}")
        if M65_TARGETS.by_fpga(self.target):
            print(f"\n  Derived Platforms: {', '.join([x.name for x in M65_TARGETS.by_fpga(self.target)])}")


NAMEre = re.compile(r'[^ -Z[\]^_a-z~]+')
class CoreFile:

    header_size = 4096

    def __init__(self, filepath: Optional[Path] = None):
        self._raw_data: bytes = b''

        self._bit_name: str = ''
        self._bit_version: str = ''
        self._core_target: Optional[MEGA65target] = None

        self._boot_caps: int = 0
        self._boot_flags: int = 0
        self._install_flags: int = 0

        self._bitstream: Optional[FpgaBitStream] = None
        self._erase_list: List[int] = []

        self._core_length: int = 0
        self._core_crc32: int = 0

        self._banner_data: bytes = b''
        self._embed_files: List[EmbeddedFile] = []

        self._erase_list: array = array('B', b'\xff'*16)

        self._filepath: Path = Path('__BUILDER__')

        self._errors: ErrorHandler = ErrorHandler()
        if filepath:
            self.from_file(filepath)

    @property
    def raw_data(self) -> bytes:
        return self._raw_data

    @raw_data.setter
    def raw_data(self, value: bytes):
        self._raw_data = value

    @property
    def filepath(self) -> Path:
        return self._filepath

    @filepath.setter
    def filepath(self, value: Path):
        self._filepath = value

    @property
    def bit_name(self) -> str:
        return self._bit_name

    @bit_name.setter
    def bit_name(self, value: Union[bytes, str]):
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._bit_name = NAMEre.sub(' ', value).strip()[:31]

    @property
    def bit_version(self):
        return self._bit_version

    @bit_version.setter
    def bit_version(self, value: Union[bytes, str]):
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._bit_version = NAMEre.sub(' ', value).strip()[:31]

    @property
    def core_target(self) -> Optional[MEGA65target]:
        return self._core_target

    @core_target.setter
    def core_target(self, value: Union[int, bytes, str, MEGA65target]):
        if isinstance(value, MEGA65target):
            self._core_target = value
            return
        if isinstance(value, bytes):
            value = zero_string(value, 'ascii')
        self._core_target = M65_TARGETS.get(value)

    @property
    def core_max_size(self) -> int:
        if self._core_target:
            return self._core_target.size * 1024
        return 0

    @property
    def bit_filename(self) -> str:
        return sanitize_filename(f"{self.core_target.name}-{self.bit_version}.bit")

    @property
    def boot_caps(self) -> int:
        return self._boot_caps

    @boot_caps.setter
    def boot_caps(self, value: int):
        self._boot_caps = value

    @property
    def boot_flags(self) -> int:
        return self._boot_flags

    @boot_flags.setter
    def boot_flags(self, value: int):
        self._boot_flags = value

    @property
    def install_flags(self) -> int:
        return self._install_flags

    @install_flags.setter
    def install_flags(self, value: int):
        self._install_flags = value

    @property
    def bitstream(self) -> Optional[FpgaBitStream]:
        return self._bitstream

    @bitstream.setter
    def bitstream(self, value: Optional[FpgaBitStream]):
        self._bitstream = value

    @property
    def core_length(self) -> int:
        return self._core_length
    
    @core_length.setter
    def core_length(self, value: int):
        self._core_length = value

    @property
    def core_crc32(self) -> int:
        return self._core_crc32
    
    @core_crc32.setter
    def core_crc32(self, value: int):
        self._core_crc32 = value

    @property
    def banner_data(self) -> bytes:
        return self._banner_data
    
    @banner_data.setter
    def banner_data(self, value: Optional[bytes]):
        if not value:
            self._banner_data = b''
            return
        if len(value) > BANNER_SIZE:
            raise ValueError("banner data bigger than 32k")
        self._banner_data = value

    @property
    def banner_data_array(self) -> array:
        return array('B', self._banner_data + b'\x00'*(BANNER_SIZE - len(self.banner_data)))

    @property
    def has_banner(self) -> bool:
        return self._banner_data != b''

    @property
    def banner_size(self) -> int:
        return BANNER_SIZE if self.has_banner else 0

    @property
    def embed_files(self) -> List[EmbeddedFile]:
        return self._embed_files

    @property
    def embed_count(self) -> int:
        return len(self._embed_files)

    @property
    def embed_size(self) -> int:
        return sum([x.raw_data_length for x in self._embed_files])

    @property
    def erase_list(self) -> array:
        return self._erase_list

    @staticmethod
    def _format_erase_list(data: array) -> str:
        res: List[str] = []
        for x in data:
            if x == 0xff:
                break
            res.append(f'${x:02X}')
        return ', '.join(res)

    @property
    def erase_list_str(self) -> str:
        return self._format_erase_list(self._erase_list)

    @property
    def has_errors(self) -> bool:
        return len(self._errors) > 0

    def todict(self) -> dict:
        return {
            'CoreFile': {
                'version': 0,
                'length': self.core_length,
                'crc32': self.core_crc32,
                'target': self.core_target.name,
                'bit_name': self.bit_name,
                'bit_version': self.bit_version,
                'boot_caps': M65_CAPS.get_active_str(self.boot_caps),
                'boot_flags': M65_CAPS.get_active_str(self.boot_flags),
                'install_flags': M65_INST.get_active_str(self.install_flags),
                'bit_filename': str(self.bit_filename),
                'embed_files': [x.name for x in self.embed_files],
            }
        }

    def tojson(self) -> str:
        return json.dumps(self.todict(), indent=4)

    def find_file(self, name: str) -> Optional[EmbeddedFile]:
        for file in self._embed_files:
            if file.name == name:
                return file
        return None

    def add_file(self, filepath: Union[str, Path]) ->  EmbeddedFile:
        if isinstance(filepath, str):
            filepath: Path = Path(filepath)
        if self.find_file(filepath.name):
            raise FileError('duplicate filename')
        try:
            data = filepath.open('rb').read()
        except (FileNotFoundError, IOError) as err:
            raise FileError(err)
        obj = EmbeddedFile(filepath.name, data)
        if self.header_size + (self.bitstream.raw_data_length if self.bitstream else 0) + self.embed_size + self.banner_size + obj.raw_data_length > self.core_max_size:
            raise FileError("core size exceeded")
        self._embed_files.append(obj)
        return obj

    def add_fileobj(self, obj: EmbeddedFile):
        self._embed_files.append(obj)

    def add_files(self, files: List[str]):
        for file in files:
            self.add_file(file)

    def remove_file(self, pattern: str) -> List[str]:
        removed: List[str] = []
        new_files: List[EmbeddedFile] = []
        for file in self._embed_files:
            if fnmatch.fnmatch(file.name, pattern):
                removed.append(file.name)
                continue
            new_files.append(file)
        self._embed_files = new_files
        return removed

    def rename_file(self, old: str, new: str) -> bool:
        for file in self._embed_files:
            if file.name == old:
                file.name = new
                return True
        return False

    def smart_sort_files(self):

        def embedsmartsort(embed: EmbeddedFile) -> str:
            if embed.name == 'MEGA65.ROM':
                return '000000001' + embed.name
            if embed.name == 'ETHLOAD.M65':
                return '000000002' + embed.name
            if embed.name == 'FREEZER.M65':
                return '000000009' + embed.name
            if embed.name == 'BANNER.M65':
                return 'zzzzzzzzz' + embed.name
            return embed.name

        self._embed_files = [x for x in sorted(self._embed_files, key=embedsmartsort)]

    @staticmethod
    def _generate_erase_list(data: bytes) -> array:
        res: List[int] = []
        base: int = 0
        while True:
            offset: int = data[base:].find(SYNCWORD)
            if offset == -1:
                break
            sec: int = (base + offset) // FLASHSECTOR
            if sec > 0 and sec not in res:
                res.append(sec)
            base += offset + 4
        res.extend([0xff]*(16 - len(res)))
        return array('B', res)

    def check(self) -> Optional[str]:
        if M65_INST.check('factory', self.install_flags) and self.bit_name != 'MEGA65':
            return f'core name needs to be "MEGA65" not "{self.bit_name}", if FACTORY install flag is set'
        return None

    def generate(self) -> bytes:
        if not self.bitstream or not self.core_target or not self.bit_name or not self.bit_version:
            raise ValueError("need at least bitstream, target, name and version to build core")

        # calculate full length
        self.core_length = self.core_max_size
        if not self.has_banner:
            if not self.embed_count:
                self.core_length = 4096 + self.bitstream.raw_data_length
            else:
                self.core_length = self.embed_files[-1].next + 40

        buffer: array = array('B', b'\x00' * self.core_length)

        embed_offset: int = 4096 + self.bitstream.raw_data_length if self.embed_count else 0
        struct.pack_into("<16s32s32s32sBBBIIBBBHII", buffer, 0,
                         CORE_MAGIC,
                         self.bit_name.encode('ascii'), self.bit_version.encode('ascii'),
                         self.core_target.name.encode('ascii'), self.core_target.code,
                         1 if self.has_banner else 0, self.embed_count, embed_offset, 0,
                         self.boot_caps, self.boot_flags, self.install_flags, 0,
                         self.core_length, CORE_CRC32_I)

        buffer[4096:4096+self.bitstream.raw_data_length] = array('B', self.bitstream.raw_data)
        if self.has_banner:
            buffer[-BANNER_SIZE:] = self.banner_data_array

        for file in self.embed_files:
            file.offset = embed_offset
            file.next = embed_offset + 40 + file.raw_data_length
            struct.pack_into('<II32s', buffer, embed_offset, file.next, file.raw_data_length, file.name.encode('ascii'))
            buffer[embed_offset + 40:file.next] = array('B', file.raw_data)
            embed_offset = file.next

        buffer[0xf0:0x100] = self._generate_erase_list(buffer.tobytes())
        if buffer[0xf0] != 0xff:
            buffer[0x7d] |= M65_INST.get('_eraselist')

        struct.pack_into('<I', buffer, 0x84, crc32(buffer.tobytes()))

        self.raw_data = buffer.tobytes()
        return buffer.tobytes()

    def from_file(self, filepath: Path, data: Optional[bytes] = None):
        if data is None:
            data: bytes = filepath.open('rb').read()

        self._errors = errors = ErrorHandler()

        res = struct.unpack("<16s32s32s32sBBBIIBBBHII104s16s", data[:256])
        if res[0] != CORE_MAGIC:
            raise FileError("not a Corefile, magic mismatch!")

        self.bit_name = res[1]
        if self.bit_name != zero_string(res[1], 'ascii'):
            errors['bit_name'] = f'name mangled from "{zero_string(res[1], "ascii")}"'
        self.bit_version = res[2]
        if self.bit_version != zero_string(res[2], 'ascii'):
            errors['bit_version'] = f'version mangled from "{zero_string(res[2], "ascii")}"'
        self.core_target = res[4]
        if self.core_target is None:
            errors['core_target'] = f'unknown core_target code ${res[4]:02X}'
        else:
            btn = zero_string(res[3], 'ascii')
            if self.core_target.name != btn:
                errors['core_target'] = f"core_target name {zero_string(res[3], 'ascii')} does not match ${res[4]:02X}"

        has_banner: bool = res[5] != 0
        if has_banner:
            self.banner_data = data[-BANNER_SIZE:]

        embed_count: int = res[6]
        next_offset: int = res[7]
        # 8 is filler

        self.boot_caps = res[9]
        if M65_CAPS.has_invalid_bits(self.boot_caps):
            errors['boot_caps'] = 'Undefined bits are set'
        self.boot_flags = res[10]
        if M65_CAPS.has_invalid_bits(self.boot_flags):
            errors['boot_flags'] = 'Undefined bits are set'
        elif self.boot_flags & self.boot_caps != self.boot_flags:
            errors['boot_flags'] = 'Flags without Caps'
        self.install_flags = res[11]
        if M65_INST.has_invalid_bits(self.install_flags):
            errors['install_flags'] = 'Undefined bits are set'
        # 12 is filler

        self.core_length = res[13]
        if self.core_length != len(data):
            errors['core_length'] = f'Core length mismatch {len(data)}' if self.core_length > 0 else 'Old bitstream file without length'
        self.core_crc32 = res[14]
        # 15 is filler

        if M65_INST.check('_eraselist', self.install_flags):
            self.erase_list[:] = array('B', res[16])
        gen_el = self._generate_erase_list(data)
        if self.erase_list != gen_el:
            errors['eraselist'] = 'eraselist should be: ' + self._format_erase_list(gen_el)

        if M65_INST.check('factory', self.install_flags) and self.bit_name != FACTORY_NAME:
            errors['bit_name'] = f'Factory core name is not "{FACTORY_NAME}"'

        check_core_crc32: int = crc32(data[:0x84] + b'\xf0\xf0\xf0\xf0' + data[0x88:])
        if self.core_crc32 != check_core_crc32:
            errors['core_crc32'] = f'CRC32 mismatch, should be {check_core_crc32:08X}' if self.core_crc32 != 0 else 'Old bitstream file without CRC32'

        self.bitstream = FpgaBitStream(self.bit_name, data[4096:next_offset] if next_offset else data[4096:])
        if self.bitstream.target != self.core_target.fpga:
            errors['bitfile_target'] = f'Core {self.core_target.fpga} != bitstream {self.bitstream.target}'

        while next_offset > 0:
            res = struct.unpack("<II32s", data[next_offset:next_offset+40])
            if res[0] == 0:
                break
            embed = EmbeddedFile(zero_string(res[2], 'ascii'), data[next_offset+40:res[0]], next_offset, res[0])
            if embed.offset + 40 + res[1] != embed.next:
                embed.errors.append('Embed file chaining error')
            self.add_fileobj(embed)
            if embed.name == 'BANNER.M65' and self.banner_data and embed.raw_data != self.banner_data[:embed.raw_data_length]:
                errors['banner'] = 'BANNER.M65 does not match embedded banner data'
            if embed.next > len(data) or embed.next < next_offset:
                errors['embed_eof'] = f'Chaining error at file {self.embed_count}'
                break
            next_offset = embed.next
        if embed_count != self.embed_count:
            errors['embed_count'] = f'embed count mismatch (header: {embed_count})'

        self.filepath = filepath
        self.raw_data = data

    def print_info(self):
        # core info
        print(f'COREFILE "{self.filepath.name}"')
        print(format_error_line(f"@@ Core length: {self.core_length} (file {self.core_length})", self._errors.get('core_length')))
        print(format_error_line(f"@@ Core CRC32:  {self.core_crc32:08X}", self._errors.get('core_crc32')))
        print(format_error_line(f"@@ Core Target: {self.core_target.code:02X} - {self.core_target.name} - {self.core_target.fpga}", self._errors.get('bithdr_target') + self._errors.get('bitfile_target')))

        # bitstream 1 info
        print(f"  BITSTREAM 1")
        print(format_error_line(f"  @@ Name:          {self.bit_name}", self._errors.get('bit_name')))
        print(format_error_line(f"  @@ Version:       {self.bit_version}", self._errors.get('bit_version')))
        print(format_error_line(f"  @@ Capabilities:  {M65_CAPS.get_active_str(self.boot_caps)}", self._errors.get('boot_caps')))
        print(format_error_line(f"  @@ Active Flags:  {M65_CAPS.get_active_str(self.boot_flags)}", self._errors.get('boot_flags')))
        print(format_error_line(f"  @@ Install Flags: {M65_INST.get_active_str(self.install_flags)}", self._errors.get('install_flags')))
        print(format_error_line(f"  @@ Eraselist:     {'yes - ' + self.erase_list_str if M65_INST.check('_eraselist', self.install_flags) else 'no'}", self._errors.get('eraselist')))

        # file info
        print(f"  EMBEDDED FILES")
        print(f"    Has embedded banner: {'yes' if self.has_banner else 'no'}")
        print(format_error_line(f"  @@ File count: {self.embed_count}", self._errors.get('embed_count')))
        embed_next = 0
        for num, embed in enumerate(self.embed_files):
            print(format_error_line(f"    @@ FILE {num:2d}: {embed.name:32s} length {embed.raw_data_length:8d} offset {embed.offset:8d} next {embed.next:8d}", embed.errors))
            embed_next = embed_next
        if self.embed_count:
            print(format_error_line(f"    @@ EOF                                       length        0 offset {embed_next:8d} next        0", self._errors.get('embed_eof')))
        if len(self._errors):
            log.info('tip: use --modify on this file to fix errors in-place')


class MCSFile:

    def __init__(self, filepath: Optional[Union[str, Path]] = None):
        self._filepath: Path = None
        self._raw_data: bytes = None
        self._offset: int = 0
        if filepath is not None:
            if type(filepath) is str:
                filepath = Path(filepath)
            self.from_file(filepath)

    @property
    def filepath(self) -> Path:
        return self._filepath
    
    @property
    def raw_data(self) -> bytes:
        return self._raw_data
    
    @raw_data.setter
    def raw_data(self, data: bytes):
        self._raw_data = data

    @property
    def offset(self) -> int:
        return self._offset
    
    @offset.setter
    def offset(self, offset: int):
        if offset & 0xffff != 0:
            log.warning("offset is not aligned to 16 bit, truncating")
        self._offset = offset & 0xffff0000

    @property
    def filetype(self) -> str:
        if not self._raw_data:
            return 'EMPTY'
        if self._raw_data[:len(CORE_MAGIC)] == CORE_MAGIC:
            return 'M65-Core'
        if self._raw_data[:16] == TRUNCBIT_MAGIC:
            return 'Trunc-Bit'
        return 'UNKNOWN'

    @property
    def corefile(self) -> Optional[CoreFile]:
        if self.filetype != 'M65-Core':
            return None
        obj = CoreFile()
        try:
            obj.from_file(self.filepath, self.raw_data)
        except FileError as err:
            log.error(f"failed to interpret MCS content as Corefile: {err}")
            return None
        return obj

    def __repr__(self) -> str:
        return f'<MCSFile "{self.filepath.name}" @{self.offset:08X} {len(self._raw_data)}b {self.filetype}>'

    @staticmethod
    def _calc_checksum(data: array) -> int:
        return (((sum(data) & 0xff) ^ 0xff) + 1) & 0xff

    def from_file(self, filepath: Path):
        self._raw_data = b''
        self._offset = 0
        blob: bytes = b''
        linenum: int = 0
        highaddr: int = -1
        nextaddr: int = -1
        for line in filepath.open('rt', encoding="ascii"):
            linenum += 1
            line = line.strip()
            if not line:
                continue

            if line[0] != ':':
                raise FileError("MCS data line does not start with ':'")

            data = array('B', bytes.fromhex(line[1:]))
            if self._calc_checksum(data[:-1]) != data[-1]:
                raise FileError(f"checksum error in line {linenum}")

            if data[3] not in (0, 1, 4):
                raise FileError(f"unknown record type {data[3]} in line {linenum}")

            if data[3] == 4: # addr offset
                if data[1] != data[2] != 0:
                    raise FileError(f"invalid addr offset record in line {linenum}")
                newhigh = (data[4] << 8) + data[5]
                if highaddr != -1 and newhigh != highaddr + 1:
                    raise FileError(f"high address discontinuity error in line {linenum:08d}: {newhigh} != {highaddr + 1}")
                highaddr = newhigh
                nextaddr = 0
                self._raw_data += blob
                blob = b''
                continue
            
            if data[3] == 1: # end marker
                self._raw_data += blob
                break

            if highaddr < 0 or nextaddr < 0:
                raise FileError(f"unexpected nextaddr in line {linenum}")
            
            thisaddr = (data[1] << 8) + data[2]
            if nextaddr != thisaddr:
                raise FileError(f"address discontinuity error in line {linenum:08d}: {thisaddr} != {nextaddr}")
            blob += data[4:-1]
            nextaddr = thisaddr + data[0]

        self._filepath = filepath

    def print_info(self):
        print(f'MCSFILE "{self.filepath.name}"')
        print(f"  Content: {self.filetype}")
        print(f"  Offset:  0x{self.offset:08X}")
        print(f"  Size:    {len(self.raw_data)}")
        core = self.corefile
        if core:
            print()
            core.print_info()

    def save_data(self, path: Path):
        path.open('rb').write(self._raw_data)

    def write_file(self, path: Path):
        highaddr: int = (self.offset >> 16) & 0xffff
        nextaddr: int = 0
        with path.open('wt', encoding='ascii', buffering=131072) as fp:
            try:
                data: bytes = array('B', self.raw_data)
                datalen: int = len(data)
                offset: int = 0
                while offset < datalen:
                    if nextaddr == 0:
                        checksum = (((2 + 4 + (highaddr & 0xff) + ((highaddr >> 8) & 0xff)) ^ 0xff) + 1) & 0xff
                        line = f':02000004{highaddr:04X}{checksum:02X}\n'
                        fp.write(line)
                    linelen = min(16, datalen - offset)
                    checksum = (((linelen + (nextaddr & 0xff) + ((nextaddr >> 8) & 0xff) + sum(data[offset:offset+linelen])) ^ 0xff) + 1) & 0xff
                    line = ':' + (struct.pack('>BHB', linelen, nextaddr, 0) + data[offset:offset+linelen].tobytes() + bytes([checksum])).hex().upper() + '\n'
                    fp.write(line)
                    offset += linelen
                    nextaddr = nextaddr + linelen
                    if (nextaddr >> 16) > 0:
                        nextaddr = 0
                        highaddr += 1
                fp.write(':00000001FF\n')
            except IOError as err:
                log.error(f"Error while writing MCS file: {err}")

def open_file(filepath: Union[str, Path]) -> Optional[Union[CoreFile, MCSFile, FpgaBitStream]]:
    if isinstance(filepath, str):
        filepath = Path(filepath)

    fileobj: Union[CoreFile, MCSFile, FpgaBitStream] = None
    try:
        header = filepath.open('rb').read(256)
    except (FileNotFoundError, IOError) as err:
        log.error(f"Failed to open file: {err}")
        return None

    if header[:9] == b':02000004':
        try:
            fileobj = MCSFile(filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            log.error('Failed to load MCSFile "{filepath.name}": {err}')
            return None
        else:
            log.info(f'Opened MCS file "{filepath.name}"')

    elif header[:len(CORE_MAGIC)] == CORE_MAGIC:
        try:
            fileobj = CoreFile(filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            log.error(f'Failed to load Corefile "{filepath.name}": {err}')
            return None
        else:
            log.info(f'Opened Corefile "{filepath.name}"')

    elif (header[:len(VIVADO_BIT_HEADER)] == VIVADO_BIT_HEADER or
          (header[:len(TRUNCBIT_MAGIC)] == TRUNCBIT_MAGIC and header.find(SYNCWORD) < 512)):
        try:
            fileobj = FpgaBitStream(filepath=filepath)
        except (FileError, FileNotFoundError, IOError) as err:
            log.error(f'Failed to load FPGA Bitstream "{filepath.name}": {err}')
            return None
        else:
            log.info(f'Opened Bitstream file "{filepath.name}"')
    else:
        log.error(f"Found unknown file header, can't work with \"{filepath.name}\"")
        return None

    return fileobj


def return_if_exists(args: argparse.Namespace, path: Path) -> bool:
    if path.exists() and not args.force:
        log.error(f'Target file "{path.name}" exists, use --force to overwrite anyway')
        return True
    return False


def verify_file(args: argparse.Namespace) -> int:
    log.debug("Started verify file action")
    fileobj = open_file(args.verify)
    if fileobj:
        fileobj.print_info()
        return 0
    return 1


def build_core(args: argparse.Namespace, bitobj: Optional[FpgaBitStream] = None) -> int:
    filepath: Path = Path(args.build)
    if return_if_exists(args, filepath):
        return 1

    if args.bit is None:
        log.error("Please provide a bitstream file using --bit/-b")
        return 1

    bits = [x for x in zip_longest(args.bit, args.name or [], args.version or [])]
    if len(bits) != 1:
        log.error("coretool can currently handle only one bitstream")
        return 1

    core = CoreFile()

    if bitobj is None:
        bitobj = open_file(bits[0][0])
        if bitobj is None or not isinstance(bitobj, FpgaBitStream) or bitobj.is_truncated:
            log.error("Build requires a full Bitstream to work on")
            return 1

    core.bitstream = bitobj

    if args.target is None:
        target = bitobj.guess_target
        if target:
            log.info(f"Target guessed to be {target.name}/${target.code:02X}")
    else:
        target = M65_TARGETS.get(args.target)
    
    if target is None:
        log.error("Failed to guess target, use --target/-t to specify")
        return 1

    name = bits[0][1]
    if not name:
        name = bitobj.guess_name
        if name:
            log.info(f'Name guessed to be "{name}"')
    if not name:
        log.error("Please provide a name for the core using --name/-n")
        return 1

    version = bits[0][2]
    if not version:
        version = bitobj.guess_version
        if version:
            log.info(f'Version guessed to be "{version}"')
    if not version:
        log.error("Please provide a version for the core using --version/-v")

    core.core_target = target
    core.bit_name = name
    core.bit_version = version

    if args.caps:
        core.boot_caps, errs = M65_CAPS.parse_str(args.caps)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid boot caps found (use list to show valid options)")
            return 1

    if args.flags:
        core.boot_flags, errs = M65_CAPS.parse_str(args.flags)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid boot flags found (use list to show valid options)")
            return 1

    if args.install:
        core.install_flags, errs = M65_INST.parse_str(args.install)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid install flags found (use list to show valid options)")
            return 1

    add_files: list = []
    if args.add_files:
        add_files.extend([Path(x) for x in args.add_files])

    for filepath in add_files:
        try:
            obj = core.add_file(filepath)
        except FileError as err:
            log.error(f'Failed to add "{filepath.name}": {err}')
        else:
            logadd: str = ''
            if filepath.name == 'BANNER.M65':
                core.banner_data = obj.raw_data
                logadd = " (embedded as banner)"
            log.info(f"Embedded \"{filepath.name}\"{logadd}")

    if args.smart_sort:
        core.smart_sort_files()
        log.info('Smart sorted embedded files:')
        for embed in core.embed_files:
            log.info(f'  {embed.name}')

    if args.set_banner:
        bannerpath: Path = Path(args.set_banner)
        if core.has_banner:
            log.error("Banner already set by BANNER.M65 file")
            return 1
        try:
            core.banner_data = bannerpath.open('rb').read()
        except (FileNotFoundError, IOError, ValueError) as err:
            log.error(f'Error while setting banner to "{bannerpath.name}": {err}')
            return 1

    error: Optional[str] = core.check()
    if error:
        log.error(f'Final core check failed: {error}')
        return 1

    core.filepath = Path(args.build)
    try:
        core.filepath.open('wb').write(core.generate())
    except (FileNotFoundError, IOError) as err:
        log.error(f"Failed to write core file: {err}")
    else:
        log.info(f'Wrote corefile to "{core.filepath}"')

    return 0


def modify_file(args: argparse.Namespace, core: Optional[CoreFile] = None, destpath: Optional[Path] = None) -> int:
    filepath: Path = Path(args.modify)

    if core is None:
        core = open_file(filepath)
        if core is None:
            return 1

    changed: bool = False

    if not isinstance(core, CoreFile):
        log.error("Modify can only be used on corefile, use --convert for other formats")
        return 1

    if args.bit or (args.target and (args.target not in ('mega65r5', 'mega65r6') or core.core_target.name not in ('mega65r5', 'mega65r6'))):
        log.error(f"Modify will not allow to replace bitstream or target, use --build instead")
        return 1

    old_value: str
    if args.name:
        old_value = core.bit_name
        core.bit_name = args.name[0]
        log.info(f'Changed name to "{core.bit_name}" (was "{old_value}")')
        changed = True

    if args.version:
        old_value = core.bit_version
        core.bit_version = args.version[0]
        log.info(f'Changed version to "{core.bit_version}" (was "{old_value}")')
        changed = True

    if args.target:
        old_value = core.core_target.name
        core.core_target = args.target
        log.info(f'Changed target to "{core.core_target.name}" (was "{old_value}")')
        changed = True

    if args.caps:
        old_value = M65_CAPS.get_active_str(core.boot_caps)
        core.boot_caps, errs = M65_CAPS.parse_str(args.caps)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid boot caps found (use list to show valid options)")
            return 1
        log.info(f'Changed boot caps to {M65_CAPS.get_active_str(core.boot_caps)} (was {old_value})')
        changed = True

    if args.flags:
        old_value = M65_CAPS.get_active_str(core.boot_flags)
        core.boot_flags, errs = M65_CAPS.parse_str(args.flags)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid boot flags found (use list to show valid options)")
            return 1
        log.info(f'Changed boot flags to {M65_CAPS.get_active_str(core.boot_flags)} (was {old_value})')
        changed = True

    if args.install:
        old_value = M65_INST.get_active_str(core.install_flags)
        core.install_flags, errs = M65_INST.parse_str(args.install)
        if errs:
            for err in errs:
                log.error(err)
            log.error(f"Invalid install flags found (use list to show valid options)")
            return 1
        log.info(f'Changed install flags to {M65_INST.get_active_str(core.install_flags)} (was {old_value})')
        changed = True

    if args.remove_files:
        for pattern in args.remove_files:
            removed = core.remove_file(pattern)
            if not removed:
                log.warning(f'Remove "{pattern}" had no matches')
            else:
                for file in removed:
                    log.info(f'Removed "{file}" for pattern "{pattern}"')
                changed = True

    if args.add_files:
        for file in args.add_files:
            filepath = Path(file)
            try:
                obj = core.add_file(filepath)
            except FileError as err:
                log.error(f'Failed to add "{filepath.name}": {err}')
            else:
                log.info(f'Embedded "{filepath.name}"')
                if filepath.name == 'BANNER.M65':
                    core.banner_data = obj.raw_data
                    log.info(f"+ embedded banner automatically set to file data")
                changed = True

    if args.rename_file:
        for rename in args.rename_file:
            if core.rename_file(rename[0], rename[1]):
                log.info(f'Renamed "{rename[0]}" to "{rename[1]}"')
                changed = True
            else:
                log.error(f'Could not rename "{rename[0]}", not found')

    if args.remove_banner:
        if core.has_banner:
            core.banner_data = b''
            log.info(f'Removed embedded banner')
            changed = True
        else:
            log.warning(f'No embedded banner to remove')
    elif args.set_banner:
        bannerpath: Path = Path(args.set_banner)
        try:
            core.banner_data = bannerpath.open('rb').read()
        except (FileNotFoundError, IOError, ValueError) as err:
            log.error(f'Error while setting banner to "{bannerpath.name}": {err}')
        else:
            log.info(f'Set embedded banner to "{bannerpath.name}"')
            changed = True

    if args.smart_sort:
        core.smart_sort_files()

    error: Optional[str] = core.check()
    if error:
        log.error(f'Final core check failed: {error}')
        return 1

    if changed or core.has_errors:
        if destpath is None:
            destpath = core.filepath
        log.info('Changes detected, writing core' if changed else 'Autocorrecting errors, writing core')
        try:
            destpath.open('wb').write(core.generate())
        except (FileNotFoundError, IOError) as err:
            log.error(f"Failed to write core file: {err}")
        else:
            log.info(f'Wrote corefile to "{destpath}"')
        return 0

    log.info(f'Nothing changed, leaving file untouched')
    return 1


def extract_files(args: argparse.Namespace) -> int:
    filepath: Path = Path(args.extract)
    fileobj = open_file(filepath)
    if fileobj is None:
        return 1

    destpath: Path
    if args.extract_path is None:
        destpath = Path('.').absolute().joinpath(sanitize_filename(filepath.stem))
    else:
        destpath = Path(args.extract_path)
    if destpath.exists() and not destpath.is_dir():
        log.error("Destination exists but is not a directory")
        return 1
    if not destpath.exists():
        try:
            destpath.mkdir()
        except FileNotFoundError:
            log.error("Failed to create target directory")
            return 1
    log.error(f"Extracting to {destpath.absolute()}")

    if isinstance(fileobj, FpgaBitStream):
        log.error("Can't extract files from a bitstream, abort")
        return 1

    if isinstance(fileobj, MCSFile):
        if fileobj.filetype == "Trunc-Bit":
            destfile = destpath.joinpath(sanitize_filename(filepath.stem + '.bit'))
            if return_if_exists(args, destfile):
                return 1
            try:
                fileobj.save_data(destfile)
            except (IOError, OSError) as err:
                log.error(f'Failed to save bitstream as "{destfile.name}": {err}')
                return 1
            log.info(f'Saved truncated bitstream as "{destfile.name}"')
            return 0
        if fileobj.filetype != "M65-Core":
            destfile = destpath.joinpath(sanitize_filename(f'unknown_{filepath.stem}.dat'))
            if return_if_exists(args, destfile):
                return 1
            try:
                fileobj.save_data(destfile)
            except (IOError, OSError) as err:
                log.error(f'Failed to save content as "{destfile.name}": {err}')
                return 1
            log.info(f'Saved unknown content as "{destfile.name}"')
            return 0
        log.info(f"Found MEGA65 Corefile stored in MCS")
        fileobj = fileobj.corefile

    if isinstance(fileobj, CoreFile):
        bitnum: str = 'one' if fileobj.bitstream else 'no'
        log.info(f"Found {bitnum} bitstream and {fileobj.embed_count} embedded files")
        errors: int = 0
        destfile = destpath.joinpath(sanitize_filename(f"core.json"))
        if return_if_exists(args, destfile):
            return 1
        try:
            destfile.open('wt').write(fileobj.tojson())
        except (IOError, OSError) as err:
            log.error(f'Failed to save core json as "{destfile.name}": {err}')
            errors += 1
        else:
            log.info(f'Saved core json as "{destfile.name}"')
        if fileobj.bitstream:
            destfile = destpath.joinpath(fileobj.bit_filename)
            if return_if_exists(args, destfile):
                return 1
            try:
                fileobj.bitstream.save_data(destfile)
            except (IOError, OSError) as err:
                log.error(f'Failed to save bitstream as "{destfile.name}": {err}')
                errors += 1
            else:
                log.info(f'Saved bitstream as "{destfile.name}"')
        for embed in fileobj.embed_files:
            destfile = destpath.joinpath(sanitize_filename(embed.name))
            if return_if_exists(args, destfile):
                return 1
            try:
                embed.save_data(destfile)
            except (IOError, OSError) as err:
                log.error(f'Failed to save embedded as "{destfile.name}": {err}')
                errors += 1
            else:
                log.info(f'Saved embedded file "{destfile.name}"')
        return errors

    return 0

def convert_files(args: argparse.Namespace) -> int:
    path_from: Path = Path(args.convert[0])
    path_to: Path = Path(args.convert[1])

    if return_if_exists(args, path_to):
        return 1

    if path_from.is_dir() and path_from.joinpath('core.json').exists() and path_to.suffix.lower() == '.cor':
        log.info('Building core from extraction path')
        try:
            coreinfo: dict = json.load(path_from.joinpath('core.json').open('rb'))
        except (FileNotFoundError, IOError) as err:
            log.error(f'Failed to load core.json: {err}')
            return 1
        args.build = args.convert[1]
        if not args.bit:
            args.bit = [path_from.joinpath(coreinfo['CoreFile']['bit_filename'])]
        if not args.target:
            args.target = coreinfo['CoreFile']['target']
        if not args.name:
            args.name = [coreinfo['CoreFile']['bit_name']]
        if not args.version:
            args.version = [coreinfo['CoreFile']['bit_version']]
        if not args.caps:
            args.caps = coreinfo['CoreFile']['boot_caps']
        if not args.flags:
            args.flags = coreinfo['CoreFile']['boot_flags']
        if not args.install:
            args.install = coreinfo['CoreFile']['install_flags']
        if args.add_files is None:
            args.add_files = []
        for file in coreinfo['CoreFile']['embed_files']:
            args.add_files.append(path_from.joinpath(file))
        return build_core(args)

    fileobj = open_file(path_from)
    if fileobj is None:
        return 1

    if path_to.suffix.lower() == '.mcs':
        if args.offset is None:
            args.offset = 0
        elif isinstance(args.offset, str) and args.offset.startswith('S'):
            if isinstance(fileobj, CoreFile) and fileobj.core_target:
                args.target = fileobj.core_target
            if isinstance(args.target, str):
                args.target = M65_TARGETS.get(args.target)
            if args.target is None:
                log.error("Offset in slot format requires --target to be set")
                return 1
            slot: int = int(args.offset[1:])
            if slot < 0 or slot > 7:
                log.errror("Only slot 0 to 7 are supported")
                return 1
            args.offset = args.target.size * slot * 1024
        else:
            try:
                args.offset = int(args.offset, 0)
            except ValueError as err:
                log.error('Unable to parse --offset "{args.offset}": {err}')
                return 1

    if isinstance(fileobj, FpgaBitStream):
        if path_to.suffix.lower() == '.cor':
            log.warning('Conversion from FPGA Bitstream to Corefile should be done with --build, trying anyways...')
            args.build = args.convert[1]
            args.bit = [args.convert[0]]
            return build_core(args, bitobj=fileobj)
        if path_to.suffix.lower() != '.mcs':
            log.error(f"Invalid conversion target {path_to.suffix.lower()[1:]} for FPGA Bitstream")
            return 1
        mcs: MCSFile = MCSFile()
        # bit2mcs does remove the bitstream header... so we do the same...
        mcs.raw_data = fileobj.raw_data_truncated
        mcs.offset = args.offset
        try:
            mcs.write_file(path_to)
        except (IOError, OSError) as err:
            log.error(f'Failed to write "{path_to.name}": {err}')
            return 1
        log.info(f'Converted bitstream to MCS "{path_to.name}"')
        return 0

    if isinstance(fileobj, CoreFile):
        if path_to.suffix.lower() == '.cor':
            args.modify = args.convert[0]
            return modify_file(args, fileobj, destpath=path_to)
        if path_to.suffix.lower() == '.mcs':
            mcs: MCSFile = MCSFile()
            # bit2mcs does remove the bitstream header... so we do the same...
            mcs.raw_data = fileobj.raw_data
            mcs.offset = args.offset
            try:
                mcs.write_file(path_to)
            except (IOError, OSError) as err:
                log.error(f'Failed to write "{path_to.name}": {err}')
                return 1
            log.info(f'Converted Corefile to MCS "{path_to.name}" at ${mcs.offset:08X}')
            return 0
        if path_to.suffix.lower() == '.bit':
            # we just save the bitstream...
            try:
                fileobj.bitstream.save_data(path_to)
            except (IOError, OSError) as err:
                log.error(f'Failed to write "{path_to.name}": {err}')
                return 1
            log.info(f'Converted Corefile to FPGA Bitstream "{path_to.name}"')
            return 0
        log.error(f'Invalid conversion target {path_to.suffix.lower()[1:]} for Corefile')
        return 1

    if isinstance(fileobj, MCSFile):
        if fileobj.filetype == 'M65-Core':
            if path_to.suffix.lower() in ('.bit', '.mcs'):
                log.warning("MCS contains MEGA65 Corefile, changing suffix to .cor")
                path_to = path_to.with_suffix('.cor')
            target = 'MEGA65 Corefile'
        elif fileobj.filetype == 'Trunc-Bit':
            if path_to.suffix.lower() in ('.mcs', '.cor'):
                log.warning("MCS contains truncated FPGA Bitstream, changing suffix to .bit")
                path_to = path_to.with_suffix('.bit')
            target = 'FPGA Bitstream'
        else:
            if path_to.suffix.lower() in ('.mcs', '.cor', '.bit'):
                log.warning("MCS contains unknown data, changing suffix to .dat")
                path_to = path_to.with_suffix('.dat')
            target = 'unknown data'

        try:
            path_to.open('wb').write(fileobj.raw_data)
        except (IOError, OSError) as err:
            log.error(f'Failed to write "{path_to.name}": {err}')
            return 1
        log.info(f'Converted MCS File to {target} "{path_to.name}"')
        return 0

    return 1


class CustomHelpFormatter(argparse.HelpFormatter):

    def _fill_text(self, text, width, indent):
        import textwrap
        result = []
        for paragraph in re.split('\n\n\n+[ \t]*', text):
            paragraph = self._whitespace_matcher.sub(' ', paragraph).strip()
            result.append(textwrap.fill(paragraph, width,
                                        initial_indent=indent,
                                        subsequent_indent=indent))
        return '\n\n'.join(result)


def main():
    global DO_COLOR, WIDTH

    parser = argparse.ArgumentParser("coretool", formatter_class=CustomHelpFormatter,
                                     description=f"{CBOLD if DO_COLOR else ''}!!!UNFINISHED!!! STILL IN DEVELOPMENT!!!{CST if DO_COLOR else ''}\n\n\nMEGA65 Corefile utility",
                                     epilog=f"""{CBOLD if DO_COLOR else ''}WARNING:{CST if DO_COLOR else ''} if you are not a developer, this tool is probably not for you!\n\n
                                     This tool allows the construction, modification and verification of MEGA65 core files, as well as the conversion between Corefile,
                                     FPGA Bitstream and the Intel MCS-86 fileformat (also used by Vivado).\n\n
                                     A Corefile is mainly used to flash bistreams in a defined way into your MEGA65 mainboard. This is done with the MEGAFLASH utility,
                                     which you can bring up by holding down NO-SCROLL and then powering on your mega65.\n\n
                                     {CBOLD if DO_COLOR else ''}!!!UNFINISHED!!! STILL IN DEVELOPMENT!!!{CST if DO_COLOR else ''}""")
    actions = parser.add_argument_group("Action", "The main function that is executed")
    actions_ex = actions.add_mutually_exclusive_group(required=True)
    actions_ex.add_argument('--verify', '-V', metavar="FILE", type=str, help="Display information about a file.")
    actions_ex.add_argument('--build', '-B', metavar="COREFILE", type=str, help="Build a new corefile.")
    actions_ex.add_argument('--modify', '-M', metavar="COREFILE", type=str, help="Modify an existing corefile.")
    actions_ex.add_argument('--extract', '-X', metavar="COREFILE", type=str,
                            help="Extract all files from a corefile. Use --extract-path to specify the destination path.")
    actions_ex.add_argument('--convert', '-C', metavar="FILE", type=str, nargs=2,
                            help="Convert one type of file into the other. Note: convert will automatically call --build or --modify if needed.")

    group = parser.add_argument_group('Logging & Output')
    group.add_argument('--debug', '-d', action="store_true", help="Enable debug output.")
    group.add_argument('--quiet', '-q', action="store_true", help="Only display errors.")

    group = parser.add_argument_group('Generic')
    group.add_argument('--force', '-F', action="store_true", help="Force overwriting existing files.")
    group.add_argument('--offset', metavar="OFFSET", type=str, help="Offset to be set when converting a corefile to the MCS format. Defaults to 0. Use 0x prefix for hex numbers or S prefix for Slot.")
    group.add_argument('--extract-path', metavar="PATH", type=str, help="Target path for the extract action. Defaults to current directory (plus filename if corefile).")
    group.add_argument('--smart-sort', action="store_true", help="Enable smart sorting of embedded files. This will put often used files at the start for speed improvement.")
    coloropt = group.add_mutually_exclusive_group()
    coloropt.add_argument('--color', action="store_true", default=None, help="Enable Color on output(autodetect).")
    coloropt.add_argument('--no-color', action="store_false", default=None, help="Disable Color on output (autodetect).")
    group.add_argument('--width', type=int, help="Terminal width (autodetected if possible).")

    group = parser.add_argument_group('Bitstream',
                                      """The bitstream is the FPGA programming information that makes your MEGA65 behave a certain way. You set the name and the version
                                      displayed in MEGAFLASH with the respective options. The target platform is derived from the provided bitstream content and name, but
                                      in case of ambiguity the tool will ask you to provide the target.""")
    group.add_argument('--target', '-t', metavar="TARGET", type=str, help="Target platform name (list to show allowed values).")
    group.add_argument('--bit', '-b', metavar="BITPATH", type=str, action="append", help="Path to the bitstream to be added into the corefile.")
    group.add_argument('--name', '-n', metavar="NAME", type=str, action="append", help="Sets the display name for the bitstream.")
    group.add_argument('--version', '-v', metavar="VERSION", type=str, action="append", help="Sets the display version of the bitstream.")

    group = parser.add_argument_group('Corefile flags',
                                      """The core capabilities define special handling through MEGAFLASH on system startup. It is divided in two parts: the capabilities
                                      define which of the capabilities are supported by this core, the flags define which of those supported capabilities are set by
                                      default. You can use MEGAFLASH to change then inside the system (only flags in the capability set can be changed!).\n\n
                                      Note: if multiple core slots have the same flag set, the core in the slot  with the lowest number wins.\n\n
                                      The install flags handle special core installation cases. With this a core can be marked as a valid slot 0 core and certain security
                                      options can be disabled or the core might even be installed automatically.""")
    group.add_argument('--caps', '-c', metavar="CAPS", type=str, help="Set capabilities (list to show allowed values)")
    group.add_argument('--flags', '-f', metavar="CAPS", type=str, help="Set active flags (list to show allowed values)")
    group.add_argument('--install', '-i', metavar="INST", type=str, help="Set install flags (list to show allowed values)")

    group = parser.add_argument_group('Embedded files',
                                      """It is possible to embed files into the core, right after the bitstream. This are used by the Fdisk utilility to populate the SDcard
                                      after formatting, and it allows to add a BANNER.M65 to a special place, so the booting core can access it more quickly from there.""")
    banner = group.add_mutually_exclusive_group()
    banner.add_argument('--set-banner', metavar="FILE", type=str, help="Add banner file (<32KB) at the end of the corefile. Note: this is not added as an embedded file.")
    banner.add_argument('--remove-banner', action="store_true", help="(Modify) Remove embedded banner from corefile. Note: will not remove the embedded file.")
    group.add_argument('--add-files', metavar="FILE", type=str, nargs="+", help="List of files to add after the bitstream. Note: a file named \"BANNER.M65\" will be automatically set as banner.")
    group.add_argument('--remove-files', metavar="FILE", type=str, nargs="+", help="(Modify) List of files to remove from the corefile. You can use glob patterns (escape!) or the special keyword ALL (caps!).")
    group.add_argument('--rename-file', metavar="FILE", type=str, nargs=2, action="append", help="(Modify) Rename file found inside the corefile.")

    args = parser.parse_args()

    if args.color is not None:
        DO_COLOR = args.color

    root_logger = logging.getLogger()
    log_ch = logging.StreamHandler(sys.stderr)
    log_ch.setLevel(logging.DEBUG if args.debug else (logging.ERROR if args.quiet else logging.INFO))
    log_fmt = logging.Formatter(LOG_FORMAT)
    log_ch.setFormatter(log_fmt)
    root_logger.addHandler(log_ch)
    root_logger.setLevel(logging.DEBUG if args.debug else (logging.ERROR if args.quiet else logging.INFO))

    log.debug(f'main: {args=}')

    if args.width:
        WIDTH = args.width
    else:
        WIDTH = shutil.get_terminal_size().columns - 2

    # check if some parameters are unclear and we need to print a list of valid options
    did_list: bool = False
    if args.caps == 'list' or args.flags == 'list':
        print("\nAllowed capabilities (list multiple separated by comma):")
        print(M65_CAPS.get_help(indent='    '))
        did_list = True
    
    if args.install == 'list':
        print("\nAllowed install flags (list multiple separated by comma):")
        print(M65_INST.get_help(indent='    '))
        did_list = True

    if args.target == 'list':
        print("\nRecognized MEGA65 target specification:")
        print(M65_TARGETS.get_help(indent='    '))
        did_list = True
    
    if did_list:
        print()
        sys.exit(0)

    # do the actions
    result: int = 1
    if args.verify is not None:
        result = verify_file(args)
    elif args.build:
        result = build_core(args)
    elif args.modify:
        result = modify_file(args)
    elif args.convert is not None:
        result = convert_files(args)
    elif args.extract is not None:
        result = extract_files(args)

    log.info(f"Exiting coretool ({result})")
    sys.exit(result)

if __name__ == '__main__':
    main()
